#!/bin/bash
# ------------------------------------------------------------------------------
# Index + Centauri Bash Script Library Documentation
#
#+General:  The library was written to simplify the creation of bash scripts that
#           look like standard linux (command line) apps with options, usage help
#           and solid error handling.
#
#+          It is split into modules (bash source files). The main module file is
#           [[_centauri_bash_lib]]. The documentation is organized in **module**, **topic**
#           and **function** entries.
#
# Content:  [[Help]]                 How to use the [[_centauri_bash_lib]] documentation
#           [[Introduction]]         General information about [[_centauri_bash_lib]]
#           [[Module]]               List of modules and versions
#           [[Content]]              Documentation content by module
#           [[Reference]]            [[Topics]]/[[functions]]/[[modules]] reference by name
#           [[Applications]]         Tools written with [[_centauri_bash_lib]]
#
# Modules:  ###autogenerated###
#
# Copyright Dr. J. Pfennig (c) 2019-2022
# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
# Modules + Name and Version Reference - _centauri_bash_lib
#
#+Versioning: Each tool or module has a version and a minimum api-level. These are
#+          specified as ''<version>:<api-level>''. The ''<api-level>'' field of module
#+          [[_centauri_bash_lib]] defines the library api-level.
#
# Copyright Dr. J. Pfennig (c) 2019-2022
#
# ###autogenerated###
# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
# Content + Documentation content by module - _centauri_bash_lib
#
#+General:  The documentation is structured by **modules**, **functions** and **topics**.
#           Each **module** is a bash script, and **functions** are always contained
#           in **modules**. **Topics** have no executable code.
#
#+          The main module [[_centauri_bash_lib]] must be sourced by the user
#           script. Other modules can be loaded dynamically.
#
# Copyright Dr. J. Pfennig (c) 2019-2022
#
# ###autogenerated###
# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
# Reference + Function Reference by Name - _centauri_bash_lib
#
#+Summary:  The documentation is organized in [[modules]], [[topics]] and [[functions]].
#           Tools that are using [[_centauri_bash_lib]] are documented at [[Applications]].
#
# Copyright Dr. J. Pfennig (c) 2019-2022
#
# ###autogenerated###
# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
# Tools + Name and Version Reference - centauritools
#
#+Versioning: Each tool or module has a version and a minimum api-level. These are
#           specified as ''<version>:<api-level>''. The ''<api-level>'' field of module
#           [[_centauri_bash_lib]] defines the library api-level.
#
# Copyright Dr. J. Pfennig (c) 2019-2022
#
# ###autogenerated###
# ------------------------------------------------------------------------------
CEN_LEGAL="Copyright Dr. J. Pfennig (c) 2019-2022; BSD License"
CEN_TITLE=$"Documentation generator for centauri-bash-lib and centauritools"

PATH+=":${0%/*}" . _centauri_bash_lib -a -d -f -i -r -t -y "$0" "0.14:1" || exit 2

# Data
CEN_RUN_MIN_ARGS=0              # min arg count, see arguments()
CEN_RUN_MAX_ARGS=+              # max arg count

CEN_OPT_ALL=                    # see --all
CEN_OPT_CONTENT=                # see --content
CEN_OPT_DELETE=                 # see --delete
CEN_OPT_FILE=                   # see --file
CEN_OPT_GENERATE=               # see --generate
CEN_OPT_HTML=                   # see --html
CEN_OPT_INDEX=                  # see --index
CEN_OPT_L10N=                   # see --l10n
CEN_OPT_LIBRARY=                # see --library
CEN_OPT_LINES=                  # see --lines
CEN_OPT_MODULES=                # see --modules
CEN_OPT_REFERENCE=              # see --refence
CEN_OPT_TOOLS=                  # see --tools
CEN_OPT_USE=                    # see --use

DAT_DOCO="-5 -i 0"              # xml_document options

DAT_FMT_MODE=                   # 0: text  1: deco  2:html
DAT_FMT_TYPE=plain              # call suffix 'plain' or 'html'
DAT_FMT_PARSE=full              # call suffix 'full' or 'mini' (parser)

DAT_FMT_ULIN=                   # ANSI underline
DAT_FMT_BOLD=                   # ANSI bold
DAT_FMT_ITAL=                   # ANSI italics
DAT_FMT_NORM=                   # ANSI normal mode

DAT_AUTOLIST=                   # set formatter()
DAT_AUTOTRIM=

DAT_SEP_ITEM=                   # separator line
DAT_OUT_OPTS=                   # options for output
DAT_CNT_FILE=0                  # file counter
DAT_CNT_ITEM=0                  # items ...

DAT_INP_FILE=                   # from documentation worker
DAT_INP_LINE=                   # input file/line, see linesplit()
DAT_INP_NAME=                   # element name, see linesplit()
DAT_OUT_FILE=                   # output file, see processing()

DAT_MOD_VERS=                   # module version, see module()
DAT_MOD_MAINT=                  # maintenance tools flag

DAT_FLG_EBEG=                   # flags open section, see element_item_html
DAT_FLG_ECNT=                   # section counter, see ...

DAT_TAB_ROWS=()                 # used with xml_table to fill table

DAT_CHAR_MARKER='-+.,'          # format marker chars, set for []
DAT_CHAR_LABEL='-°[:word:]'     # chars allowed in label, set for []
                                # static links: [<name> [<file>]] ...
DAT_BOOKMARK=('library index' 'applications tools' 'autoload' 'uglify' 'l10n-tool'
 'centauribuilder' 'centauricreate' 'centaurihelp' 'centaurilauncher' 'centauripaths')
                                # utilities that are part of the library
DAT_UTILS=('library/autoload' 'library/uglify' 'locale/l10n-tool')

# --- serializable data ---

DAT_REF_FUNCTIONS=()    # list of functions, see reference()
DAT_REF_MODULES=()      # list of modules/topics/tools, ...
DAT_REF_TOPICS=()
DAT_REF_TOOLS=()

declare -A DAT_BMK_NAMES DAT_BMK_TOOLS      # bookmark: link/tools name lookup

DAT_SERIALIZE="DAT_REF_TOOLS DAT_REF_MODULES DAT_REF_TOPICS DAT_REF_FUNCTIONS"
DAT_SERIALIZE+=" DAT_BMK_NAMES DAT_BMK_TOOLS"

# --- filled from deserialized data ---

declare -A DAT_BMK_NEXT DAT_BMK_PREV

# ------------------------------------------------------------------------------
# generate html: -no args-
# ------------------------------------------------------------------------------
generate() {
    # helper to create a redirect file: <dest> <file>
    ___redirect() {
        [ -z "$1" ] && { xml_element meta -n -a "$___redirect_meta" ; return ; }
        [ -h "$2" ] && remove -f "$2"
        local ___redirect_meta="http-equiv='refresh' content='0; url=file://$1'"
        xml_document $DAT_DOCO -t $"Redirection" -o "$2" -h ___redirect
    }
    ___dummytxt() {
        local mesg ; splitjoin -d "\n" -j mesg \
            $"To generate Html documentation please type (as a user with suffient rights):" \
            "" "    $CEN_NAME --delete --generate=all" "" \
            $"If you want only centauritools or centauri-bash-lib documentation, replace" \
            $"the option value 'all' by 'tools' or 'library'."
        xml_document $DAT_DOCO -t $"Generating Html Documentation" -o "$2" -b
        xml_element pre -- "$mesg" ; xml_document -e
    }

    local copt="${CEN_OPT_GENERATE::1}"
    local item="${CEN_OPT_HTML:-$CEN_ROOT/html}"
    local rsub=___redirect ; [ "$copt" = "d" ] && rsub=___dummytxt
    folder -f "$item"
    confirm -a $"Generate Html documentation at:" "$item" || quit
    [ "$copt" = "a" -o "$copt" = "t" ] && embed -t -v -y -- "$BASH_SOURCE" -T -H "$item" -
    [ "$copt" = "a" -o "$copt" = "l" ] && embed -t -v -y -- "$BASH_SOURCE" -A -H "$item" -
    [ "$copt" = "a" -o "$copt" = "t" ] && embed -t -v -y -- "$BASH_SOURCE" -T -H "$item"
    [ "$copt" = "a" -o "$copt" = "l" ] && embed -t -v -y -- "$BASH_SOURCE"    -H "$item"
    error -t || quit
    [ "${copt/[adt]/}" != "$copt" ] && $rsub "$item/tools.html" "$CEN_TOOLS/README.html"
    [ "${copt/[adl]/}" != "$copt" ] && $rsub "$item/index.html" "$CEN_LIBRARY/README.html"
    quit $"Done."
}

# ------------------------------------------------------------------------------
# includes - write default.js and default.css
# ------------------------------------------------------------------------------
includes() {
    [ "${CEN_OPT_HTML:-/dev/stdout}" = "/dev/stdout" ] && return
    system -c cat
    local fhan file item

    for item in "js" "css" ; do
        file="$CEN_OPT_HTML/default.$item"
        if [ "$BASH_SOURCE" -nt "$file" ] ; then
            dryrun "Creating: $file" && continue
            redirect -s -v fhan -x "$file" || return
            includes_$item >&$fhan
            redirect -s -v fhan
        fi
    done
}

# ------------------------------------------------------------------------------
includes_js() {
    cat <<!EOF
/* default.js - autogenerated by $CEN_NAME - do not edit */
!EOF
}

# ------------------------------------------------------------------------------
includes_css() {
    cat <<!EOF
/* default.css - autogenerated by $CEN_NAME - do not edit */

/* --- tag selectors --- */

a {
    font-family: monospace;
    text-decoration: none;
    color: inherit;
}

body {
    background-color: #eff6f8;
    margin-top: 0;
    margin-bottom: 0;
}

p {
    margin: 1em;
    text-align: justify;
    font-size: 12pt;
}

i, em, b {
    font-family: monospace;
}

pre {
    background-color: ivory;
    padding: 4pt;
    border: 2pt;
    border-style: dotted;
    border-color: burlywood;
    margin: 4pt 0 0 0;
    min-width: 50em;
    width: 50em;
}

/* --- headers --- */

h2, div.item-module {
    font-size: 14pt;
    background-color: lavender;
    margin-top: 1em;
    border-style: outset;
    border-width: thin;
    padding: 3pt;
}

div.item-script {
    font-size: 14pt;
    background-color: aquamarine;
    margin-top: 1em;
    border-style: outset;
    border-width: thin;
    padding: 3pt;
}

div.item-header {
    font-size: 14pt;
    background-color: beige;
    margin-top: 1em;
    margin-bottom: 1em;
    border-style: outset;
    border-width: thin;
    padding: 3pt;
}

div.item-topic {
    font-size: 14pt;
    background-color: khaki;
    margin-top: 1em;
    border-style: outset;
    border-width: thin;
    padding: 3pt;
}

div.item-function {
    font-size: 14pt;
    background-color: wheat;
    margin-top: 1em;
    border-style: outset;
    border-width: thin;
    padding: 3pt;
}

/* --- definitions --- */

div.def-row {
    display: table-row;
}

div.def-label {
    display: table-cell;
    padding-top: 1em;
    min-width: 8em;
    font-weight: bold;
    font-size: 11pt;
}

div.def-empty {
    display: table-cell;
    width: 8em;
    font-size: 11pt;
}

div.def-text {
    display: table-cell;
    font-size: 11pt;
    font-family: monospace;
    white-space: pre;
}

div.def-block {
    display: table-cell;
    font-size: 11pt;
    font-family: monospace;
}

div.def-break {
    height: 6pt;
}

/* ---- table for index etc. ---- */

table {
    font-size: 11pt;
    margin-left: 0.5em;
    border-spacing: 8pt 2pt;
}

td {
    font-weight: bold;
}

td.module, td:first-child {
    font-family: monospace;
    font-weight: normal;
    border: 1pt solid black;
    padding: 2pt 2pt 2pt 8pt;
    background-color: lavender;
    min-width: 14em;
}

td.topic {
    font-family: monospace;
    font-weight: normal;
    border: 1pt solid black;
    padding: 2pt 8pt 2pt 8pt;
    background-color: khaki;
}

td.function {
    font-family: monospace;
    font-weight: normal;
    border: 1pt solid black;
    padding: 2pt 8pt 2pt 8pt;
    background-color: wheat;
}

/* ---- navigator (table layout) ---- */

nav {
    font-size: 11pt;
    display: table;
    width: 100%;
    background-color: cadetblue;
    color: white;
    font-weight: bold;
    border-style: solid;
    border-width: thin;
    border-color: black;
    box-sizing: border-box;
}

div.nav-row {
    display: table-row;
}

div.nav-left {
    display: table-cell;
    width: 30%;
    text-align: left;
}

div.nav-right {
    display: table-cell;
    width: 30%;
    text-align: right;
}

div.nav-mid {
    display: table-cell;
    width: 20%;
    text-align: center;
}

/* ---- colorize anchors in defines ---- */

.def-block a {
    color: blueviolet;
}

.def-text a {
    color: blueviolet;
}

/* ---- join navigation with 1st section ---- */

#section-1 div {
    margin-top: 0;
}
!EOF
}

# ------------------------------------------------------------------------------
# parser - use regular expressions to parse text (return via BASH_REMATCH)
# ------------------------------------------------------------------------------
REX_apos="(.*)'(')'(.*)"            # '''       Literal apostroph
REX_litr="(.*)''(.*)''(.*)"         # ''xxx''   literals
REX_bold="(.*)\*\*(.*)\*\*(.*)"     # **xxx**   bold
REX_quot="(.*)(\".*\")(.*)"         # "xxx"     quoted
REX_ital="(.*)<<(.*)>>(.*)"         # <<xxx>>   italics
REX_link="(.*)\[\[(.*)\]\](.*)"     # [[xxx]]   link
REX_void="(.*)<()>(.*)"             # <>        placeholder

REX_hash="(.* |^)(# .*)"            # used by formatter()
REX_para="(.* )§ (.*)"              # used by formatter()
REX_vari="(.*)<([a-zA-Z][a-zA-Z|]*)>(.*)"       # varibale
REX_cons="(.*[^A-Z_]|^)([A-Z_]+_[A-Z_]*)(.*)"   # constant

REX_sopt="(.*[^-a-zA-Z]|^)(-[-a-zA-Z])([^-a-zA-Z].*|$)" # short option
REX_lopt="(.*)(--[a-z]*)(.*)"                           # long option
REX_plus="(.*[\[|])([-+])(\|.*|].*)"    # syntax notation

parser_full() {
    # bash globbing is used in a 1st step because bash regex is quite slow
    # The glob expression is only used to reduce the number of regex calls.

    [[ "$1" == *\'\'\'* ]]     && [[ "$1" =~ $REX_apos ]] && return 1
    [[ "$1" == *\'\'* ]]       && [[ "$1" =~ $REX_litr ]] && return 1
    [[ "$1" == *\*\** ]]       && [[ "$1" =~ $REX_bold ]] && return 3  # bold
    [[ "$1" == *\"*\"* ]]      && [[ "$1" =~ $REX_quot ]] && return 3  # bold
    [[ "$1" == *\[\[*\]\]* ]]  && [[ "$1" =~ $REX_link ]] && return 4  # ulin
    [[ "$1" == *\<\<*\>\>* ]]  && [[ "$1" =~ $REX_ital ]] && return 2  # ital
    [[ "$1" == *\<\>* ]]       && [[ "$1" =~ $REX_void ]] && return 5

    [ "$DAT_FMT_MODE" = "0" ] && return 0       # simple text formatting

    [[ "$1" == *-[a-zA-Z-]* ]]       && [[ "$1" =~ $REX_sopt ]] && return 3  # bold
    [[ "$1" == *--[a-zA-Z]* ]]       && [[ "$1" =~ $REX_lopt ]] && return 3  # bold
    [[ "$1" == *\<[a-zA-Z]*\>* ]]    && [[ "$1" =~ $REX_vari ]] && return 2
    [[ "$1" == *[A-Z]_[A-Z]* ]]      && [[ "$1" =~ $REX_cons ]] && return 3  # bold
    [[ "$1" == *[\[\|][-+][\]\|]* ]] && [[ "$1" =~ $REX_plus ]] && return 3  # bold

    [ -n "$DAT_INP_NAME" ] && [[ "$1" == *$DAT_INP_NAME* ]] &&
        [[ "$1" =~ (.* |^)($DAT_INP_NAME)([^a-z].*|$) ]] && return 3
    return 0
}

parser_mini() {
    [[ "$1" == *\'\'\'* ]]     && [[ "$1" =~ $REX_apos ]] && return 1
    [[ "$1" == *\'\'* ]]       && [[ "$1" =~ $REX_litr ]] && return 1
    [[ "$1" == *\*\** ]]       && [[ "$1" =~ $REX_bold ]] && return 3  # bold ???
    [[ "$1" == *\"*\"* ]]      && [[ "$1" =~ $REX_quot ]] && return 3  # bold

    [ "$DAT_FMT_MODE" = "0" ] && return 0       # simple text formatting

    [[ "$1" == *-[a-zA-Z-]* ]]       && [[ "$1" =~ $REX_sopt ]] && return 3  # bold
    [[ "$1" == *--[a-zA-Z]* ]]       && [[ "$1" =~ $REX_lopt ]] && return 3  # bold
    [[ "$1" == *[A-Z]_[A-Z]* ]]      && [[ "$1" =~ $REX_cons ]] && return 3  # bold

    [ -n "$DAT_INP_NAME" ] && [[ "$1" == *$DAT_INP_NAME* ]] &&
        [[ "$1" =~ (.* |^)($DAT_INP_NAME)([^a-z].*|$) ]] && return 3
    return 0
}

# ------------------------------------------------------------------------------
# text formatting: formatter <text>   # see DAT_FMT_MODE
# ------------------------------------------------------------------------------
# find symlin target (return: _temp)
formatter_deco_link() {
    _temp="${1,,}"
    case "$_temp" in
        index|content|module|reference|tools)
                    _temp+='.html' ; return 0 ;;
        _*_*_*)     _temp+='.html' ; return 0 ;;
        [a-z]*)     bookmark -c _temp "$_temp" && return 0 ;;
    esac
    return 1
}

# create decorated output: <mode> <left> <deco> <righ> (return: _temp)
formatter_deco_plain() {
    case "$1" in
        2)  _temp="$2$DAT_FMT_ITAL$3$DAT_FMT_NORM$4" ;;
        3)  _temp="$2$DAT_FMT_BOLD$3$DAT_FMT_NORM$4" ;;
        4)  _temp="$2$DAT_FMT_ULIN$3$DAT_FMT_NORM$4" ;;
        5)  [ "$DAT_FMT_MODE" = '0' ] && _temp="$2  $4"
            [ "$DAT_FMT_MODE" = '1' ] && _temp="$2$4" ;;
        *)  _temp="$2$3$4"
    esac
}

formatter_deco_html() {
    local _esc3 _eleb _elee
    case "$1" in
        2)  _eleb='<i>'  ; _elee='</i>' ;;
        3)  _eleb='<b>'  ; _elee='</b>' ;;
        4)  if formatter_deco_link "$3" ; then
                _eleb="<a href=\"$_temp\">" ; _elee='</a>'
            else
                _eleb='<em>' ; _elee='</em>'
            fi ;;
        5)  _temp="$2$4" ;  return ;;
    esac
    xml_text -v _esc3 -- "$3"
    _temp="$2$_eleb$_esc3$_elee$4"
}

# helper to recursively parser input: <text>
formatter_full() {
    local _mode
    parser_$DAT_FMT_PARSE "$1"
    case $? in
        1)  ;;
        2)  [ -z "$_mraw" ] && _mode=2 ;;
        3)  [ -z "$_mraw" ] && _mode=3 ;;
        4)  [ -z "$_mraw" ] && _mode=4 ;;
        5)  [ -z "$_mraw" ] && _mode=5 ;;
        *)  [ "$DAT_FMT_MODE" = "2" ] || return 1   # no change
            xml_text -v _temp -- "$1" ; return 0    # escape html
    esac

    local _tmp1="${BASH_REMATCH[1]}"
    local _tmp2="${BASH_REMATCH[2]}"
    local _tmp3="${BASH_REMATCH[3]}"
    # echo "    MATCH: $_tmp1|$_tmp2|$_tmp3"

    # recurse only if not single char
    if [ "${#_tmp1}" -gt 1 ] ; then
        formatter_full "$_tmp1" && _tmp1="$_temp"
    elif  [ "$DAT_FMT_MODE" = "2" ] ; then
        xml_text -v _tmp1 -- "$_tmp1"
    fi
    if [ "${#_tmp3}" -gt 1 ] ; then
        formatter_full "$_tmp3" && _tmp3="$_temp"
    elif  [ "$DAT_FMT_MODE" = "2" ] ; then
        xml_text -v _tmp3 -- "$_tmp3"
    fi

    formatter_deco_$DAT_FMT_TYPE "$_mode" "$_tmp1" "$_tmp2" "$_tmp3"
    return 0
}

# format without decorating, return length difference in _diff
formatter_diff() {
    local _styp="$DAT_FMT_TYPE" _smod="$DAT_FMT_MODE"
    DAT_FMT_TYPE=plain ; DAT_FMT_MODE=1
    _mraw=1
    if formatter_full "$1" ; then           # changed something
        DAT_FMT_TYPE="$_styp" ; DAT_FMT_MODE="$_smod"
        _mraw= ; _diff=$((${#1} - ${#_temp}))
        [ "$_diff" -gt 0 ] ; return         # return status
    else                                    # nothing changed
        DAT_FMT_TYPE="$_styp" ; DAT_FMT_MODE="$_smod"
        _mraw= ; return 1
    fi
}

formatter() {
    local _temp _mraw _diff _mesg

    # --- setup ---

    if [ -z "$DAT_FMT_MODE" ] ; then
        if [ -n "$CEN_OPT_HTML" ] ; then
            DAT_FMT_MODE=2
        elif console ; then
            printf -v DAT_FMT_BOLD "$CEN_DECO_BOLD"
            printf -v DAT_FMT_ITAL "$CEN_DECO_ITAL"
            printf -v DAT_FMT_ULIN "$CEN_DECO_ULIN"
            printf -v DAT_FMT_NORM "$CEN_DECO_NORM"
            DAT_FMT_MODE=1
        else
            DAT_FMT_MODE=0
        fi
    fi

    # --- do the formatting ----

    local -n _varg="$1"
    local _mesg="${_varg//°/ }"                     # ° is an alias for space
    if [ "$_varg" != "$_mesg" ] ; then              # may be quoted: ''°''
        local _quot="${_varg//\'\'°\'\'/$'\a'}"
        if [ "$_varg" = "$_quot" ] ; then           # not quoted
            _varg="$_mesg"
        else
            _quot="${_quot//°/ }" ; _varg="${_quot//$'\a'/°}"
        fi
    fi
    if [ -z "${_varg// /}" ] ; then                 # empty line
        DAT_AUTOLIST= ; DAT_AUTOTRIM= ; return
    fi

    # keep indentation for inline comments
    if [[ "$_varg" == *\ #\ * ]] && [[ "$_varg" =~ $REX_hash ]] ; then
        local _tmp1="${BASH_REMATCH[1]}"            # left side
        local _tmp2="${BASH_REMATCH[2]}"            # the comment

        # do format the left side without decorations to get the
        # length difference of printable characters ...
        formatter_diff "$_tmp1" &&                  # changed, indent...
            printf -v _tmp1 "%s%${_diff}s" "$_tmp1" ""
        formatter_full "$_tmp1" && _tmp1="$_temp" # format left side
        [ -n "$CEN_OPT_HTML" ] && xml_text -v _tmp2 -- "$_tmp2"
        _varg="$_tmp1$_tmp2" ; DAT_AUTOLIST= ; DAT_AUTOTRIM=

    # keep indentation for § marker
    elif [[ "$_varg" == *\ §\ * ]] && [[ "$_varg" =~ $REX_para ]] ; then
        local _tmp1="${BASH_REMATCH[1]}"            # left side
        local _tmp2="${BASH_REMATCH[2]}"            # the remainder
        formatter_diff "$_tmp1" &&                  # changed, indent...
            printf -v _tmp1 "%s%${_diff}s" "$_tmp1" ""
        formatter_full "$_tmp1" && _tmp1="$_temp"   # format left side
        formatter_full "$_tmp2" && _tmp2="$_temp"   # format remainder
        _varg="$_tmp1$_tmp2" ; DAT_AUTOLIST= ; DAT_AUTOTRIM=

    # auto list mode - after normal output line only - if line is indented
    elif [ "$DAT_FMT_MODE" != "0" -a -n "$DAT_AUTOLIST" ] &&
         [ "${#_varg}" -gt 4 -a "${_varg::4}" = "    " ] ; then
        if [ -z "$DAT_AUTOTRIM" ] ; then            # not a follow-up line
            local _len1="${_varg%%[! ]*}" ; _len1="${#_len1}"
            local _left="${DAT_AUTOLIST::_len1}"
            formatter_diff "$_left" &&              # changed something...
                DAT_AUTOTRIM="$_diff"
        fi
        [ -n "$DAT_AUTOTRIM" ] && _varg="${_varg:$DAT_AUTOTRIM}"
        formatter_full "$_varg" && _varg="$_temp"

    # no inline comment
    else
        DAT_AUTOTRIM=
        if formatter_full "$_varg" ; then
            DAT_AUTOLIST="$_varg" ; _varg="$_temp"
        else
            DAT_AUTOLIST=
        fi
    fi
}

# ------------------------------------------------------------------------------
# Format a definition: [-b|-o] <labl> <line>...
#
#   -b      remark mode (HTML: justify)
#   -o      append mode (HTML: no vertical space)
#
# There are five processing modes:
#
# Mark: ' '  Simple : full decoration, auto formatting
#       '+'  Justify: full decoration, auto formatting    (HTML: justify)
#       ','  List   : full decoration, minimal formatting (HTML: preformatted)
#       '-'  Literal: minimal decoration, no formatting   (HTML: preformatted)
#       '.'  Example: minimal decoration, no formatting   (HTML: preformatted)
# ------------------------------------------------------------------------------
definition() {
    local oflg
    while [ "${1::1}" = "-" ] ; do
      case "$1" in
      --)   shift ; break ;;
      -b)   oflg="-" ;;
      -o)   oflg="+" ;;
      *)    _cen_abort - "$1"
      esac ; shift
    done

    DAT_AUTOLIST=
    if [ "$#" = 0 ] ; then
        definition_$DAT_FMT_TYPE
    else
        definition_$DAT_FMT_TYPE "$oflg" "$@"
    fi
    DAT_FMT_PARSE=full                  # call suffix 'full' or 'mini' (parser)
}

# ------------------------------------------------------------------------------
# Format a definition: - <indent> <label> <line>...
# ------------------------------------------------------------------------------
DAT_DEF_OPEN=       # flags that HTML output needs <br>
DAT_DEF_IDNT=10     # input text: full margin (3 tabs of 4)
DAT_DEF_MODE=       # processing mode, see definition_split()

# handle label/message split: <line> [uses 'labl, mesg, lout']
definition_split() {
    # if the 1st text char was a space, it got removed by documentation()
    DAT_DEF_MODE="${mesg::1}"                   # text prefix
    case "$DAT_DEF_MODE" in
        .)  mesg="${mesg:1}" ; DAT_FMT_PARSE=mini ;;    # should become a box
        ,)  mesg="${mesg:1}" ;;                         # should become a list
        -)  mesg="${mesg:1}" ; DAT_FMT_PARSE=mini ;;    # justify
        +)  mesg="${mesg:1}" ;;                         # justify
        *)  DAT_DEF_MODE=
    esac

    local lmar="${mesg::DAT_DEF_IDNT}"
    if [ -z "${lmar// /}" ] ; then              # has full margin....
        mesg="${mesg:DAT_DEF_IDNT}"
    else                                        # just trim left...
        mesg="${mesg#"${mesg%%[![:space:]]*}"}"
    fi

    if [ -n "$labl" ] ; then                    # remove label
        local llen="${#labl}"
        # this works only if the label is not repeated
        if [ "$labl" = "${mesg::llen}" ] ; then
            mesg="${mesg:llen}"
        fi
        mesg="${mesg#"${mesg%%[![:space:]]*}"}"
        lout="${labl//°/ }" ; labl=             # ° are alias for space
    fi
}

definition_plain() {
    local idnt="$1" labl="$2" mesg pref lout ftrm fill ; shift 2
    [ "$idnt" = "-" -o "$idnt" = "+" ] && ftrm=1

    # empty definition (empty line)
    mesg="${1%*:-}"
    if [ -z "$labl$mesg" ] ; then
        echo ; return
    fi

    # print a definition line: pref lout mesg
    ___print() {
        if [ -z "$lout" ] ; then                # left side empty...
            if [ -z "$mesg" ] ; then
                echo "$pref"                    # empty line
            else
                printf "$pref           %s\n" "$mesg"
            fi
        else
            printf "$pref$CEN_DECO_BOLD%-11s$CEN_DECO_NORM%s\n" "$lout" "$mesg"
            lout=
        fi
    }

    # format output fragment: <vtext> <vleng>
    ___format() {
        local -n _ftxt="$1" _leng="$2"
        local _temp _mraw _diff                 # HACK variables for formatter_diff
        formatter_diff "$_ftxt"
        [ -n "$_diff" ] && ((_leng += _diff))
    }

    # loop over output lines
    while [ $# -gt 0 ] ; do
        linesplit -b mesg - - pref "$1"
        definition_split ; shift                # strip label

        [ -n "$ftrm" -a -z "$DAT_DEF_MODE" ] &&
            mesg="${mesg#"${mesg%%[![:space:]]*}"}"     # trim left

        if [ -n "$fill" ] ; then                # keep fill mode
            fill+=" $mesg" ; continue
        elif [ "$DAT_DEF_MODE" = "." ] ; then   # box mode
            mesg="┃ $mesg"
        elif [ "$DAT_DEF_MODE" = "," ] ; then   # list mode
            if [ "${mesg::2}" = "- " ] ; then
                mesg="• ${mesg:2}"
            else
                mesg="  ${mesg#"${mesg%%[![:space:]]*}"}"
            fi
        elif [ "$DAT_DEF_MODE" = '+' ] ; then   # fill mode
            fill+=" $mesg" ; continue
        fi
        formatter mesg                          # format right side
        ___print # pref lout mesg               # print line
    done
    [ -z "$fill" ] && return

    # format fill mode string
    local fwid="${CEN_COLS:-80}" ; ((fwid -= 11))
    while txtfold -f ___format -m "$fwid" -s mesg -- fill ; do
        formatter mesg                          # format right side
        ___print # pref lout mesg               # print line
    done
}

definition_html() {
    local idnt="$1" labl="$2" mesg mout lout fbox; shift 2
    local sepa=$'\n' mtxt="def-text"

    if [ "$idnt" = "-" ] ; then
        sepa=" " ; mtxt="def-block"
    elif [ "$idnt" = "+" ] ; then
        DAT_DEF_OPEN=
    fi

    # empty definition (empty line)
    mesg="${1%*:-}"
    if [ -z "$labl" ] ; then
        if [ -n "$DAT_DEF_OPEN" ] ; then
            xml_element "div" -c "def-break" -n
            DAT_DEF_OPEN=
        fi
        [ -z "$mesg" ] && return
    fi

    # loop over output lines
    while [ $# -gt 0 ] ; do
        linesplit -b mesg - - - "$1"
        definition_split ; shift                # strip label

        if [ -n "$DAT_DEF_MODE" ] ; then        # display in box
            if [ -z "$fbox" ] ; then
                sepa=$'\n'
                if [ "$DAT_DEF_MODE" = "." ] ; then
                    mout+="<pre>" ; fbox=1
                elif [ "$DAT_DEF_MODE" = "-" ] ; then
                    mout+="<pre>" ; fbox=2
                elif [ "$DAT_DEF_MODE" = "," ] ; then
                    mtxt="def-text" ; fbox=3
                elif [ "$DAT_DEF_MODE" = "+" ] ; then
                    mtxt="def-block" ; sepa=" "
                fi
            fi
        fi

        [ "$sepa" = " " ] && mesg="${mesg#"${mesg%%[![:space:]]*}"}"
        [ "$fbox" = "3" -a "${mesg::2}" = '- ' ] && mesg="•${mesg:1}"
        formatter mesg                          # format right side

        if [ -n "$mout" ] ; then                # continuation line
            if [ "$fbox" = "1" ] ; then
                mout+="$mesg" ; fbox=2
            elif [ "$fbox" = "3" ] ; then
                mout+="$sepa  $mesg"
            else
                mout+="$sepa$mesg"
            fi
        else                                    # 1st line
            if [ "$fbox" = "3" ] ; then
                mout="  $mesg"
            else
                mout="$mesg"
            fi
        fi
    done
    [ -n "$fbox" -a "$DAT_DEF_MODE" = "." ] && mout+="</pre>" ; fbox=

    xml_element "div" -b -n -i -c "def-row"
    if [ -n "$lout" ] ; then
        xml_element "div" -c "def-label" -n -t -- "$lout"
    else
        xml_element "div" -c "def-empty" -n
    fi
    xml_element "div" -n -c "$mtxt" -- "$mout"
    xml_element "div" -e -n -u
    DAT_DEF_OPEN=1
}

# ------------------------------------------------------------------------------
# Bookmark management
#
# Call:     bookmark -a <name> <kind> <file> <text>
#           bookmark -c <rslt> <item> <file> <line>
#           bookmark -m
#           bookmark -n|-p <rslt> <current>
#           bookmark -r <rslt> <name> [<file>]
#           bookmark -x <name> [<file>]
#
# Options:  -a  add to dictionary
#           -c  check against dict, return href
#           -m  init module prev/next
#           -n  next module
#           -p  previous module
#           -r  create href or ID
#           -x  add external reference to dictionary
# ------------------------------------------------------------------------------
bookmark() {
    local oadd ochk omak onxt oref oext svar snam href
    while [ "${1::1}" = "-" ] ; do
      case "$1" in
      --)   shift ; break ;;
      -a)   oadd=1 ;;
      -c)   ochk=1 ; shift ; snam="$1" ;;
      -m)   omak=1 ;;
      -n)   onxt=1 ; shift ; snam="$1" ;;
      -p)   onxt=2 ; shift ; snam="$1" ;;
      -r)   oref=1 ; shift ; snam="$1" ;;
      -x)   oext=1 ;;
      *)    _cen_abort - "$1"
      esac ; shift
    done

    local name="${1,,}" kind file text sepa=$'\a' afld skey prev
    local -n _dict _mods
    if [ -z "$CEN_OPT_TOOLS" ] ; then
        _dict=DAT_BMK_NAMES ; _mods=DAT_REF_MODULES
    else
        _dict=DAT_BMK_TOOLS ; _mods=DAT_REF_TOOLS
    fi

    # add entry to bookmark dictionary
    if [ -n "$oadd" ] ; then
        kind="$2" file="${3##*/}" text="$4"

        if [ "$kind" = "F" ] ; then
            # extra entry for function with annotation
            if [ "${name/ (*)/}" != "$name" ] ; then
                skey="${name% (*}()"
                [ -z "${_dict["$skey"]}" ] &&
                    _dict["$skey"]="$file$sepa$name()$sepa$kind$sepa$text"
            fi

            # decorate key of function with ()
            _dict["$name()"]="$file$sepa$name$sepa$kind$sepa$text"
        fi
        [ -z "${name// /}" ] && warning "Empty reference: $DAT_INP_LINE"
        _dict["${name:--}"]="$file$sepa$name$sepa$kind$sepa$text"
        return 0
    elif [ -n "$oext" ] ; then
        _dict["$name"]="${2:-$1}"
        return 0
    fi

    # make prev/next dictionaries
    if [ -n "$omak" ] ; then
        if [ -z "$CEN_OPT_TOOLS" ] ; then
            DAT_BMK_NEXT=([index]="module"   # foreward refences
                        [module]="content" [content]="reference")
            DAT_BMK_PREV=([module]="index"   # backwark references
                        [content]="module" [reference]="content")
            prev="reference"
        else
            DAT_BMK_NEXT=() ; DAT_BMK_PREV=()
            prev="tools"
        fi
        for item in "${_mods[@]}" ; do
            item="${item%%$'\a'*}" ; item="${item##*/}"
            DAT_BMK_PREV["${item:--}"]="$prev"
            DAT_BMK_NEXT["${prev:--}"]="$item"
            prev="$item"
        done
        return 0
    fi

    if [ -n "$ochk" ] ; then
        text="${_dict["$name"]}"
        if [ -z "$text" ] ; then
            warning -a -p $"Link target '%s' not defined: %s" "$name" "$DAT_INP_LINE"
            return 1
        fi
        splitjoin -s afld -d "\a" "$text"
        file="${afld[0]}" ; name="${afld[1]}"

    elif [ "$onxt" = "1" ] ; then
        file="${DAT_BMK_NEXT["$name"]}" ; name=
    elif [ "$onxt" = "2" ] ; then
        file="${DAT_BMK_PREV["$name"]}" ; name=

    elif [ -n "$oref" ] ; then
        file="$2"
    fi

    # format refence and save it
    if [ "${snam:--}" != "-" ] ; then       # save result
        file="${file##*/}"                  # no path
        if [ -z "$name" ] ; then
            [ -n "$file" ] && href="$file.html"
        elif [ -z "$file" ] ; then
            href="#${name//[ ()]/}"
        elif [ "$file.html" = "${DAT_OUT_FILE##*/}" ] ; then
            href="#${name//[ ()]/}"
        else
            href="$file.html#${name//[ ()]/}"
        fi
        local -n svar="$snam" ; svar="$href"
    fi
    [ -n "$href" ]                          # return status
}

# ------------------------------------------------------------------------------
# label part of a text line: <vlbl> <text>
# ------------------------------------------------------------------------------
labelsplit() {
    [ "${2/:/}" = "$2" ] && return 1                    # no colon
    local -n _vlbl="$1"
    _vlbl="${2%%:*}:"
    [ "${_vlbl//[$DAT_CHAR_LABEL]/}" = ':' ] && return 0  # valid label
    _vlbl= ; return 1                                   # not a label
}

# ------------------------------------------------------------------------------
# Split doc line: [-b] <var_text>|- <var_name|-> <var_kind>|- <var_nlin>|- <line>
# ------------------------------------------------------------------------------
linesplit() {
    local _optb
    if [ "$1" = "-b" ] ; then
        _optb=1 ; shift
    fi
    local _lnum="${5%%:*}" _tspl="${5#*:}"
    local _kspl="${_tspl::1}" ; _tspl="${_tspl:1}"

    if [ "$_optb" = 1 ] && [ "$_kspl" != "-" ] ; then   # option -b
        error $"Expected a body entry:" "$DAT_INP_FILE[$_lnum]: $_kspl"
        return 1
    fi
    [ "${2:--}" = "-" ] ||                      # want name ...
        { local -n _rnam="$2" ; _rnam="${_tspl%%:*}" ; _tspl="${_tspl#*:}" ; }

    [ "${1:--}" = "-" ] || { local -n _rtxt="$1" ; _rtxt="$_tspl" ; }
    [ "${3:--}" = "-" ] || { local -n _rknd="$3" ; _rknd="$_kspl" ; }
    [ "${4:--}" = "-" ] && return 0

    DAT_INP_LINE="$DAT_INP_FILE[$_lnum]"
    [ -n "$CEN_OPT_LINES" ] && printf -v $4 "%6s  " "$_lnum"
    [ -n "$CEN_OPT_FILE"  ] && printf -v $4 "%12s:%6s  " "$DAT_INP_FILE" "$_lnum"
    return 0
}

# ------------------------------------------------------------------------------
# print a article header, create HTML doc:
#
# Call:    article -t <mind> <mesg>                 # plain text header
#
#          article -b <file> [<mesg>]               # html document+header
#          article -h [<mesg> [<book>]]             # html header
#          article -n <curr>                        # html navigation
#          article -e <curr>                        # html footer+close doc
# ------------------------------------------------------------------------------
article() {
    local fbeg fend fnav mind="$1" file mesg book tool
    [ -z "$CEN_OPT_TOOLS" ] && tool='_centauri_bash_lib' || tool='Centauri-Tools'
    while [ "${1::1}" = "-" ] ; do
      case "$1" in
      --)   shift ; break ;;
      -b)   fbeg=1 ; shift ; file="$1" ;;
      -h)   fbeg=2 ; shift ; mesg="$1" ; book="$2" ;;
      -e)   fend=1 ;;
      -n)   fnav=1 ;;
      -t)   shift ; mind="$1" ; mesg="$2 - $tool" ;;
      *)    _cen_abort - "$1"
      esac ; shift
    done

    # html article
    if [ "$fbeg" = "1" ] ; then
        local mhdr="$CEN_NAME ─ ${mesg// - / ─ }"
        if [ -z "$mesg" ] ; then
            file="${DAT_OUT_FILE##*/}" ; mhdr+="${file%.*}"
        fi
        xml_document $DAT_DOCO -b -s "default.js" -c "default.css" \
                     -t "$mhdr" -o "$DAT_OUT_FILE" || quit
        xml_element "article#top" -b -n -i
        if [ -n "$mesg" ] ; then
            xml_element "div#item-header" -b -t -- "$mesg - "
            xml_anchor -u "index.html" "$tool"
            xml_element "div" -e -n
        fi
        DAT_ART_CURR="$book"

    # new article in same document
    elif [ -n "$fbeg" ] ; then
        xml_element "article" -e -u -n
        xml_element "article" -b -i
        if [ -n "$mesg" ] ; then
            xml_element "div${book:+#}$book" -c "item-header" -t -- "$mesg"
        fi
    elif [ -n "$fend" ] ; then
        xml_element "article" -e -n -u
        DAT_ART_CURR=1 ; article -n -- "$@" ; DAT_ART_CURR=
        xml_document -e
    elif [ -n "$fnav" ] ; then
        ___anchor() {
            local clas="$1" ; shift
            xml_element "div" -c "$clas" -b
            [ -n "$2" ] && xml_anchor "$@"
            xml_element "div" -e -n
        }
        [ -n "$DAT_ART_CURR" ] && xml_element "div" -c "def-break" -n
        local npre nnxt
        if [ "$1" != "-" ] ; then                   # skip for /dev/stdout
            bookmark -p npre "$1" ; bookmark -n nnxt "$1"
        fi
        xml_element "nav" -b ; xml_element "div" -c "nav-row" -b -n -i
            ___anchor "nav-left"  -u "$npre" "[<< previous]"
            if [ -z "$CEN_OPT_TOOLS" ] ; then
                if [ -n "$DAT_ART_CURR" ] ; then
                    ___anchor "nav-mid" -m "top" "[Top of Page]"
                else
                    ___anchor "nav-mid" -u "content.html#top" "[Content]"
                fi
                ___anchor "nav-mid"   -u "reference.html#top" "[Reference]"
            else
                if [ -n "$DAT_ART_CURR" ] ; then
                    ___anchor "nav-mid" -m "top" "[Top of Page]"
                else
                    ___anchor "nav-mid" -u "index.html#top" "[Library]"
                fi
                ___anchor "nav-mid" -u "tools.html#top" "[Tools]"
            fi
            ___anchor "nav-right" -u "$nnxt" "[next >>]"
        xml_element "div" -e ; xml_element "nav" -e -n -u

    # plain text article
    else
        local mlen="${#mesg}"
        [ -n "$CEN_OPT_LINES" ] && ((mind += 8))
        [ -n "$CEN_OPT_FILE"  ] && ((mind += 19))

        output -l
        output -i "$mind" -l -d one  -x "$mlen" .
        output -i "$mind" -l -d bold -- "$mesg"
        output -i "$mind" -l -d one  -x "$mlen" .
        output -l
    fi
}

# ------------------------------------------------------------------------------
# table of content
# ------------------------------------------------------------------------------
content() {
    DAT_INP_FILE="$1" ; shift
    local line nlin text kind name
    for line in "$@" ; do
        linesplit text name kind nlin "$line"

        case "$kind" in
        M)    content_item_$DAT_FMT_TYPE "$nlin" - "$kind" "$name" "$text" ;;
        F|T)  documentation -t "$name" "${CEN_CMDARGS[@]}" || continue
              content_item_$DAT_FMT_TYPE "$nlin" - "$kind" "$name" "$text" ;;

        A)    content_head_$DAT_FMT_TYPE ;;
        B)    content_begin_$DAT_FMT_TYPE ;;
        E)    content_end_$DAT_FMT_TYPE ;;
        Z)    content_foot_$DAT_FMT_TYPE ;;

        *)    fatal -t $"Unexpected header entry:" "$DAT_INP_LINE: $kind"
        esac
    done
    return 0
}

# ------------------------------------------------------------------------------
# table of content - plain
# ------------------------------------------------------------------------------
content_head_plain() {
    # print indented title
    article -t 23 "Table of Content"

    # print table header
    local mesg oind=36
    [ -n "$CEN_OPT_FILE"  ] && output -v mesg -x 19 -- "file name"
    [ -n "$CEN_OPT_LINES" ] && output -v mesg -- " line# |"
    [ -n "$CEN_OPT_FILE"  ] && { ((oind += 19)) ; output -v mesg -x 19 -- "file name" ; }
    [ -n "$CEN_OPT_LINES" ] && { ((oind +=  8)) ; output -v mesg       -- " line# |" ; }
    DAT_OUT_OPTS="-b $oind:6 -p"

    output -v mesg -x 22 -- "item name"
    output -v mesg -x 13 -- "|kind"
    output -v mesg       -- "|description"
    output -l -- "${mesg//|/ }"
    mesg="${mesg//[!|]/.}" ; DAT_SEP_ITEM="${mesg//|/ }"
    output -l -x "$CEN_COLS" . -d two -- "$DAT_SEP_ITEM"
    DAT_CNT_ITEM=0
}

content_foot_plain() {
    if [ -n "$CEN_OPT_LINES" ] ; then
        output -l -x "$CEN_COLS" . -d one -- "$DAT_SEP_ITEM"
        [ -n "$CEN_OPT_FILE" ] && output -x 19 -- "$DAT_CNT_FILE  [files]"
        output -p "%6s  %s\n" "$DAT_CNT_ITEM" "[modules]"
    fi
    output -l -x "$CEN_COLS" . -d two
}

content_begin_plain() {
    [ "$DAT_CNT_ITEM" != "0" ] && output -l -x "$CEN_COLS" . -d one -- "$DAT_SEP_ITEM"
}

content_end_plain() { : ; }

content_item_plain() {
    local nlin="$1" kind="$3" name="$4" text="$5" deco="ital"
    case "$kind" in
        M)    kind="Module"   ; deco="bold" ; ((++DAT_CNT_ITEM)) ;;
        F)    kind="Function" ;;
        *)    kind="Topic"    ;;
    esac
    tabulator : "${nlin% }" 22:$deco "$name" 12 "$kind" : "$text"
}

# ------------------------------------------------------------------------------
# table of content - html
# ------------------------------------------------------------------------------

# worker for index, recursive: [-w|-a] ...
content_work() {
    local arg1="$1" ; shift

    # level 0: generate doc element for "index"
    if [ "$arg1" = "-w" ] ; then
        element -a "content_work -a" -f "content" -- "$@"   # return status

    # level 1: callback for '###autogenerated###' tag
    elif [ "$arg1" = "-a" ] ; then

        ___rows() {
            local item afld kind html mark
            xml_text -v item -- "${DAT_TAB_ROWS[$2]}"
            splitjoin -s afld -d "\n" -- "$item"
            [ -z "$afld" ] && return 1

            case "${afld[1]}" in
                M)    kind="Module"   ; mark="${afld[2]}.html" ;;
                F)    kind="Function" ; bookmark -c mark "${afld[2]}()" ;;
                *)    kind="Topic"    ; bookmark -c mark "${afld[2]}" ;;
            esac

            xml_anchor -v item -u "$mark" -- "${afld[2]}"
            CEN_XML_ATTR[0]="class='${kind,,}'"
            CEN_XML_ARGS=("$item" "$kind" "${afld[3]}")
            return 0
        }

        article -h "List of documentation items grouped by module"
        xml_table -l -n -r ___rows
        DAT_TAB_ROWS=()
    fi
}

content_head_html() {
    DAT_TAB_ROWS=()
}

content_foot_html() {
    documentation "content_work -w" "$BASH_SOURCE"
}

content_begin_html() { : ; }
content_end_html() { : ; }

content_item_html() {
    local sepa=$'\n'
    DAT_TAB_ROWS+=("$2$sepa$3$sepa$4$sepa$5")
}

# ------------------------------------------------------------------------------
# callback for element listing
#
# Call:     element [-a <auto>] [-f <filter>] <file> <entry>...
# ------------------------------------------------------------------------------
element() {
    local line nlin text kind name deco head=0 fskp auto filt
    while [ "${1::1}" = "-" ] ; do
      case "$1" in
      --)   shift ; break ;;
      -a)   shift ; auto="$1" ; DAT_FLG_ECNT=0 ;;
      -f)   shift ; filt="$1" ;;
      *)    _cen_abort - "$1"
      esac ; shift
    done
    local curr skip ; DAT_INP_FILE="$1" ; shift

    # --- process header ---

    while [ $# -gt 0 ] ; do
        line="$1" ; shift
        linesplit text name kind nlin "$line"
        [ "$kind" = "-" ] && break
        name="${name##*/}"                              # strip path

        case "$kind" in
        M|F|S|T)
              # filter element by name (see documentation -q)
              if [ -n "$filt" ] ; then
                  [ "${name,,}" = "${filt,,}" ] || continue
              # must handle kind filtering here, documentation -t cannot do this
              elif [ -n "$CEN_CMDARGS" -a -z "${CEN_CMDARGS//[-+=]/}" ] ; then
                    local ksel curr="$CEN_CMDARGS"
                    [ "${curr//-/}" != "$curr" ] && ksel+='F'
                    [ "${curr//+/}" != "$curr" ] && ksel+='T'
                    [ "${curr//=/}" != "$curr" ] && ksel+='M'
                    [ "${ksel/$kind/}" = "$ksel" ] && continue
                    documentation -t "$name" "${CEN_CMDARGS[@]:1}" || continue
              elif ! documentation -t "$name" "${CEN_CMDARGS[@]}" ; then
                  continue
              fi
              # process this element ...
              DAT_INP_NAME="$name" ; ((++DAT_FLG_ECNT)) ; ((++head))
              element_item_$DAT_FMT_TYPE "$nlin" "$kind" "$name" "$text"
              ;;
        A)    DAT_FLG_EBEG= ; DAT_FLG_ECNT=0 ;;
        B)    [ "$name" = "1" ] && DAT_FLG_ECNT=0
              element_begin_$DAT_FMT_TYPE "$name" ;;
        E)    element_end_$DAT_FMT_TYPE ; DAT_INP_NAME= ;;
        Z)    ;;

        *)    fatal -t $"Unexpected header entry:" "$DAT_INP_LINE: $kind"

        esac
    done
    [ "$head" = 0 ] && return 0                         # no filter match
    element_item_$DAT_FMT_TYPE "$nlin" "$kind"          # flush header

    # --- process body ---

    local nrem=1 ngrp=0 etxt=()

    # handle a sequence of non-blank lines: <ngrp> <next>
    ___group() {
        local text texl ttmp
        linesplit -b text - - - "$etxt" || return 1

        # text mode: separate groups by empty line
        [ "$1" -gt 0 -a "$DAT_FMT_MODE" != "2" ] && definition

        # handle <auto> callback
        if [ "${text/\###autogenerated###/}" != "$text" ] ; then
            if [ -n "$auto" ] ; then
                $auto "$text" ; return
            fi
        fi

        # handle definition entry
        texl="${text#[$DAT_CHAR_MARKER]}"           # remove format marker
        if labelsplit ttmp "$texl" ; then           # get label (if any)
            nrem=
            definition -- "$ttmp" "${etxt[@]}"

        elif [ -z "$nrem" ] && [ "${texl:1:3}" = "   "  ] ; then
            definition '' "${etxt[@]}"

        # handle remarks entry
        else
            # nrem - 0: continuation   1: "Remark"   2: "Remarks"
            if [ -z "$nrem" ] ; then
                nrem=1
                texl="${2//[a-zA-Z]/}"
                [ -n "$texl" -a "${texl::1}" != ":" ] && nrem=2
            else
                nrem=0 ; [ "$DAT_FMT_MODE" = "2" ] && definition
            fi
            local labl
            if [ -n "$CEN_OPT_L10N" ] ; then
                [ "$nrem" = "1" ] && labl=$"Remark:"
                [ "$nrem" = "2" ] && labl=$"Remarks:"
            else
                [ "$nrem" = "1" ] && labl="Remark:"
                [ "$nrem" = "2" ] && labl="Remarks:"
            fi
            definition -b "$labl" "${etxt[@]}"
        fi
    }

    while true ; do
        text="${line#*:-}"                  # strip prefix
        if [ -n "$text" ] ; then            # add line to array
            etxt+=("$line")
        else                                # empty text
            if [ -n "$etxt" ] ; then        # flush group
                ___group "$ngrp" "${1#*:-}" # pass next par
                ((++ngrp)) ; etxt=()
            fi
        fi
        [ $# = 0 ] && break
        line="$1" ; shift
    done
    [ -n "$etxt" ] && ___group "$ngrp"; etxt=()

    [ "$DAT_FMT_MODE" != "2" ] && definition    # empty line
    [ -z "$filt" ]                              # false if filter was set
    documentation -t                            # return query status
}

# ------------------------------------------------------------------------------
# element listing - plain
# ------------------------------------------------------------------------------
element_begin_plain() { : ; }
element_end_plain() { : ; }

element_item_plain() {
    [ "$DAT_INP_FILE" = "/dev/stdin" ] && return    # no header for usage()
    local nlin="$1" kind="$2" name="$3" text="$4" head="${5:-1}" deco="one"
    case "$kind" in
        M)    kind="Module"   ; deco="two" ;;
        T)    kind="Topic"    ;;
        F)    kind="Function" ;;
        S)    kind="Script"   ;;
        *)    kind="Other"    ;;
    esac
    [ "$head" = 1 ] && output -l -x "$CEN_COLS" . -d "$deco"
    [ -n "$name" ] && tabulator : "${nlin% }" :bold "$kind - $name -" :bold "$text"
}

# ------------------------------------------------------------------------------
# element listing - html
# ------------------------------------------------------------------------------
element_begin_html() {
    if [ "$1" = "1" ] ; then
        article -b "$DAT_INP_FILE"
        local book="${DAT_OUT_FILE##*/}"
        article -n -- "${book%.html}"
    fi
    [ -n "$DAT_FLG_EBEG" ] && xml_element "section" -e -n -u
    DAT_FLG_EBEG=
}

element_end_html() {
    [ -n "$DAT_FLG_EBEG" ] && xml_element "section" -e -n -u
    DAT_FLG_EBEG=
    # get bookmark from output for index, content etc
    local book="${DAT_OUT_FILE##*/}"
    article -e -- "${book%.html}"
}

element_item_html() {
    local kind="$2" name="$3" text="$4" book
    if [ -z "$DAT_FLG_EBEG" ] ; then
        xml_element "section#section-$DAT_FLG_ECNT" -b -n -i
        DAT_FLG_EBEG=1
    fi

    case "$kind" in
        M)    kind="Module"   ;;
        T)    kind="Topic"    ;;
        F)    kind="Function" ;;
        S)    kind="Script"   ;;
        *)    kind="Other"    ;;
    esac

    if [ -n "$name" ] ; then
        bookmark -r book "$name"
        xml_element "div$book" -b -n -i -c "item-${kind,,}"
        xml_text -v text -- "$text"

        book="<a href=\"index.html\">Centauri Bash Library</a>"
        text="${text/Centauri Bash Library/$book}"

        book="<a href=\"index.html\">_centauri_bash_lib</a>"
        text="${text/_centauri_bash_lib/$book}"
        name="${name/_centauri_bash_lib/$book}"
        xml_element "span" -- "$kind" " - " "$name" " - " "$text"
        xml_element "div" -e -n -u
    fi
    xml_flush
}

# ------------------------------------------------------------------------------
# html index page
# ------------------------------------------------------------------------------
index() {
    DAT_INP_FILE="$1" ; shift
    local line nlin text kind name
    for line in "$@" ; do
        linesplit text name kind nlin "$line"

        case "$kind" in
        A)    documentation "index_work -w" "$BASH_SOURCE" ; return 1 ;;
        *)    fatal -t $"Unexpected header entry:" "$DAT_INP_LINE: $kind"
        esac
    done
    return 0
}

# worker for index, recursive: [-w|-a] ...
index_work() {
    local arg1="$1" ; shift

    # level 0: generate doc element for "index"
    if [ "$arg1" = "-w" ] ; then
        element -a "index_work -a" -f "index" -- "$@"   # return status

    # level 1: callback for '###autogenerated###' tag
    elif [ "$arg1" = "-a" ] ; then
        DAT_TAB_ROWS=("Modules")
        documentation -l -m -s "index_work"
        DAT_TAB_ROWS=()

    # level 2: callback for autogenerated doc entries
    else
        local text kind name
        linesplit text name kind - "$1"
        [ "$kind" = "M" ] || return 0
        printf -v name "%-24s " "[[$name]]"
        definition -o "$DAT_TAB_ROWS" ":-$name$text"
        DAT_TAB_ROWS=()
    fi
}

# ------------------------------------------------------------------------------
# list of modules
# ------------------------------------------------------------------------------
module() {
    DAT_INP_FILE="${1##*/}" ; shift
    local line nlin text kind name desc
    for line in "$@" ; do
        linesplit text - kind nlin "$line"
        name="${text%%:*}" ; desc="${text#*:}"

        case "$kind" in
        A)    DAT_MOD_VERS="unknown" ; DAT_REF_TOOLS=()
              DAT_MOD_MAINT= ; module_head_$DAT_FMT_TYPE ;;
        M|S)  if [ -z "$DAT_MOD_MAINT" -a "${name::1}" = "/" ] ; then
                  DAT_MOD_MAINT=1 ; module_maint_$DAT_FMT_TYPE
              fi
              module_item_$DAT_FMT_TYPE "$nlin" "$DAT_MOD_VERS" "$name" "$desc"
              [ "$kind" = "S" ] && DAT_REF_TOOLS+=("$name$nlin") ;;
        V)    DAT_MOD_VERS="$text" ;;
        Z)    module_foot_$DAT_FMT_TYPE
              if [ -n "$CEN_OPT_TOOLS" ] ; then
                  bookmark -m                       # create prev/next dictionaries
                  serialize -w $DAT_SERIALIZE
              fi ;;
        *)    fatal -t $"Unexpected header entry:" "$DAT_INP_LINE: $kind"
        esac
    done
    return 0
}

# ------------------------------------------------------------------------------
# list of modules - plain
# ------------------------------------------------------------------------------
module_head_plain() {
    local mesg name

    # print indented title
    if [ -z "$CEN_OPT_TOOLS" ] ; then
        article -t 23 "List of Modules" ; name="module name"
    else
        article -t 23 "List of Applications" ; name="application name"
    fi

    # print table header
    [ -n "$CEN_OPT_FILE"  ] && output -v mesg -x 19 -- "file name"
    [ -n "$CEN_OPT_LINES" ] && output -v mesg -- " line# |"
    output -v mesg -x 22 -- "$name"
    output -v mesg -x 13 -- "|version"
    output -v mesg       -- "|description"
    output -l -- "${mesg//|/ }"
    mesg="${mesg//[!|]/.}" ; DAT_SEP_ITEM="${mesg//|/ }"
    output -l -x "$CEN_COLS" . -d two -- "$DAT_SEP_ITEM"

}

module_foot_plain() {
    if [ -n "$CEN_OPT_LINES" ] ; then
        output -l -x "$CEN_COLS" . -d one -- "$DAT_SEP_ITEM"
        [ -n "$CEN_OPT_FILE" ] && output -x 19 -- "$DAT_CNT_FILE  [files]"
        output -p "%6s  %s\n" "$DAT_CNT_ITEM" "[modules]"
    fi
    output -l -x "$CEN_COLS" . -d two ; output -l
}

module_maint_plain() {
    output -l -x "$CEN_COLS" . -d one
}

module_item_plain() {
    local nlin="$1" vers="$2" name="${3##*/}" text="$4"
    ((++DAT_CNT_ITEM))
    tabulator : "${nlin% }" 22:bold "$name" 12 "$vers" : "$text"
}

# ------------------------------------------------------------------------------
# list of modules - html
# ------------------------------------------------------------------------------

# worker for index, recursive: [-w|-a] ...
module_work() {
    local styp arg1="$1" ; shift
    [ -z "$CEN_OPT_TOOLS" ] && _styp="modules" || _styp="tools"

    # level 0: generate doc element for "index" or "tools"
    if [ "$arg1" = "-w" ] ; then
        element -a "module_work -a" -f "$_styp" -- "$@"     # return status

    # level 1: callback for '###autogenerated###' tag
    elif [ "$arg1" = "-a" ] ; then
        ___rows() {
            if [ "${DAT_TAB_ROWS[$2]}" = "-" ] ; then
                xml_text -l -n "</table><div class='item-header'>Library maintenance</div><table>"
                return 0
            fi
            splitjoin -s CEN_XML_ARGS -d "\n" "${DAT_TAB_ROWS[$2]}"
            [ -n "$CEN_XML_ARGS" ]
        }

        article -h $"List of ""${_styp^}"$" and Versions"
        xml_table -l -r ___rows
        DAT_TAB_ROWS=()
    fi
}

module_head_html() {
    DAT_TAB_ROWS=()
}

module_foot_html() {
    documentation -s "module_work -w" "$BASH_SOURCE"
}

module_maint_html() {
    DAT_TAB_ROWS+=("-")
}

module_item_html() {
    local vers="$2" name="${3##*/}" text="$4" sepa=$'\n'
    ((++DAT_CNT_ITEM))
    DAT_TAB_ROWS+=("<a href=\"$name.html\">$name</a>${sepa}$vers${sepa}$text")
}

# ------------------------------------------------------------------------------
# reference tables
# ------------------------------------------------------------------------------
reference() {
    DAT_INP_FILE="$1" ; shift
    local line nlin text kind name

    for line in "$@" ; do
        linesplit text name kind nlin "$line"

        case "$kind" in
        M|F|T)
              bookmark -a "$name" "$kind" "$DAT_INP_FILE" "$text"
              reference_item "$nlin" "$kind" "$name" "$text" ;;
        A)    for line in "modules" "topics" "functions" ; do
                  bookmark -a "$line" "T" "reference" "Reference Table - $line"
              done
              reference_head ;;
        B|E)  ;;
        Z)    reference_foot ;;

        *)    fatal -t $"Unexpected header entry:" "$DAT_INP_LINE: $kind"
        esac
    done
    return 0
}

reference_head() {
    DAT_REF_FUNCTIONS=() ; DAT_REF_MODULES=() ; DAT_REF_TOPICS=()
}

reference_foot() {
    extsort -a DAT_REF_MODULES -- "${DAT_REF_MODULES[@]}"
    extsort -a DAT_REF_FUNCTIONS -- "${DAT_REF_FUNCTIONS[@]}"
    serialize -w $DAT_SERIALIZE
    documentation -s "reference_work_$DAT_FMT_TYPE -w" "$BASH_SOURCE"
}

reference_item() {
    local nlin="$1" kind="$2" name="$3" text="$4" sepa=$'\a'
    case "$kind" in
        M)  DAT_REF_MODULES+=("$name$sepa$nlin$sepa$text") ;;
        F)  documentation -t "$name" "${CEN_CMDARGS[@]}" &&
                DAT_REF_FUNCTIONS+=("$name$sepa$nlin$sepa$DAT_INP_FILE$sepa$text") ;;
        *)  documentation -t "$name" "${CEN_CMDARGS[@]}" &&
                DAT_REF_TOPICS+=("$name$sepa$nlin$sepa$DAT_INP_FILE$sepa$text") ;;
    esac
}

# ------------------------------------------------------------------------------
# references tables - plain worker, recursive: [-w|-a] ...
# ------------------------------------------------------------------------------
reference_work_plain() {
    local arg1="$1" kind="${3#*:}" oind=45 mesg item afld=()
    [ "$arg1" = "-w" ] || return
    [ "${kind::1}" = "E" ] || return
    DAT_OUT_OPTS="-b $oind:6 -p"

    # --- Topics ---

    if [ -n "$DAT_REF_TOPICS" ] ; then
        article -t 24 "Reference Table - Topics"
        [ -n "$CEN_OPT_FILE"  ] && { ((oind += 19)) ; output -v mesg -x 19 -- "file name" ; }
        [ -n "$CEN_OPT_LINES" ] && { ((oind +=  8)) ; output -v mesg       -- " line# |" ; }
        output -v mesg -x 23 -- "Topic Name"
        output -v mesg -x 21 -- "|Module"
        output -v mesg       -- "|Description"
        output -l -- "${mesg//|/ }"
        mesg="${mesg//[!|]/.}" ; DAT_SEP_ITEM="${mesg//|/ }"
        output -l -x "$CEN_COLS" . -d two -- "$DAT_SEP_ITEM"

        for item in "${DAT_REF_TOPICS[@]}" ; do
            splitjoin -s afld -d "\a" -- "$item"
            tabulator : "${afld[1]% }" 23:ital "${afld[0]}" 20:bold "${afld[2]}" : "${afld[3]}"
        done

        if [ -n "$CEN_OPT_LINES" ] ; then
            output -l -x "$CEN_COLS" . -d one -- "$DAT_SEP_ITEM"
            [ -n "$CEN_OPT_FILE" ] && output -x 19 -- "$DAT_CNT_FILE  [files]"
            output -p "%6s  %s\n" "${#DAT_REF_TOPICS[@]}" "[topics]"
        fi
        output -l -x "$CEN_COLS" . -d two
    fi

    # --- Modules ---

    article -t 22 "Reference Table - Modules"
    mesg=
    [ -n "$CEN_OPT_FILE"  ] && output -v mesg -x 19 -- "file name"
    [ -n "$CEN_OPT_LINES" ] && output -v mesg       -- " line# |"
    output -v mesg -x 21 -- "Module"
    output -v mesg       -- "|Description"
    output -l -- "${mesg//|/ }"
    mesg="${mesg//[!|]/.}" ; DAT_SEP_ITEM="${mesg//|/ }"
    output -l -x "$CEN_COLS" . -d two -- "$DAT_SEP_ITEM"

    for item in "${DAT_REF_MODULES[@]}" ; do
        splitjoin -s afld -d "\a" -- "$item"
        tabulator : "${afld[1]% }" 21:bold "${afld[0]}" : "${afld[2]}"
    done

    if [ -n "$CEN_OPT_LINES" ] ; then
        output -l -x "$CEN_COLS" . -d one -- "$DAT_SEP_ITEM"
        [ -n "$CEN_OPT_FILE" ] && output -x 19 -- "$DAT_CNT_FILE  [files]"
        output -p "%6s  %s\n" "${#DAT_REF_MODULES[@]}" "[modules]"
    fi
    output -l -x "$CEN_COLS" . -d two

    # --- Functions ---

    article -t 24 "Reference Table - Functions"
    mesg=
    [ -n "$CEN_OPT_FILE"  ] && output -v mesg -x 19 -- "file name"
    [ -n "$CEN_OPT_LINES" ] && output -v mesg       -- " line# |"
    output -v mesg -x 23 -- "Item Name"
    output -v mesg -x 21 -- "|Module"
    output -v mesg       -- "|Description"
    output -l -- "${mesg//|/ }"
    mesg="${mesg//[!|]/.}" ; DAT_SEP_ITEM="${mesg//|/ }"
    output -l -x "$CEN_COLS" . -d two -- "$DAT_SEP_ITEM"

    for item in "${DAT_REF_FUNCTIONS[@]}" ; do
        splitjoin -s afld -d "\a" -- "$item"
        tabulator : "${afld[1]% }" 23:ital "${afld[0]}" 20:bold "${afld[2]}" : "${afld[3]}"
    done

    if [ -n "$CEN_OPT_LINES" ] ; then
        output -l -x "$CEN_COLS" . -d one -- "$DAT_SEP_ITEM"
        [ -n "$CEN_OPT_FILE" ] && output -x 19 -- "$DAT_CNT_FILE  [files]"
        output -p "%6s  %s\n" "${#DAT_REF_FUNCTIONS[@]}" "[functions]"
    fi
    output -l -x "$CEN_COLS" . -d two
}

# ------------------------------------------------------------------------------
# references tables - html worker, recursive: [-w|-a] ...
# ------------------------------------------------------------------------------
reference_work_html() {
    local arg1="$1" ; shift

    # level 0: generate doc element for "refence"
    if [ "$arg1" = "-w" ] ; then
        bookmark -m                         # create prev/next dictionaries
        element -a "reference_work_html -a" -f "reference" -- "$@"  # return status

    # level 1: callback for '###autogenerated###' tag
    elif [ "$arg1" = "-a" ] ; then
        local item afld=() name file text book sepa=$'\n'
        ___rows() {
            local afld
            splitjoin -s afld -d "\n" "${DAT_TAB_ROWS[$2]}"
            [ -z "$afld" ] && return 1
            xml_element "tr" -b -i
                xml_element "td" -c "$1" -- "${afld[0]}"
                xml_element "td" -- "${afld[1]}"
                [ -n "${afld[2]}" ] && xml_element "td" -- "${afld[2]}"
            xml_element "tr" -e -u -n
            CEN_XML_ARGS=()
            return 0
        }

        # --- Topics ---

        article -h "Reference Table - Topics" "topics"

        for item in "${DAT_REF_TOPICS[@]}" ; do
            splitjoin -s afld -d "\a" -- "$item"
            # name line file text
            bookmark -r book "${afld[0]}" "${afld[2]}"
            xml_text -v name -- "${afld[0]}"
            xml_text -v file -- "${afld[2]}"
            xml_text -v text -- "${afld[3]}"
            DAT_TAB_ROWS+=("<a href=\"$book\">$name</a>${sepa}$file${sepa}$text")
        done
        xml_table -t "topic" -l -r ___rows

        # --- Modules ---

        article -h "Reference Table - Modules" "modules"

        DAT_TAB_ROWS=()
        for item in "${DAT_REF_MODULES[@]}" ; do
            splitjoin -s afld -d "\a" -- "$item"
            # name line text
            xml_text -v name -- "${afld[0]}"
            xml_text -v text -- "${afld[2]}"
            DAT_TAB_ROWS+=("<a href=\"${afld[0]}.html\">$name</a>${sepa}$text")
        done
        xml_table -t "module" -l -r ___rows

        # --- Functions ---

        article -h "Reference Table - Functions" "functions"

        DAT_TAB_ROWS=()
        for item in "${DAT_REF_FUNCTIONS[@]}" ; do
            splitjoin -s afld -d "\a" -- "$item"
            # name line file text
            bookmark -r book "${afld[0]}" "${afld[2]}"
            xml_text -v name -- "${afld[0]}"
            xml_text -v file -- "${afld[2]}"
            xml_text -v text -- "${afld[3]}"
            DAT_TAB_ROWS+=("<a href=\"$book\">$name</a>${sepa}$file${sepa}$text")
        done
        xml_table -t "function" -l -r ___rows
        DAT_TAB_ROWS=()
    fi
}

# ------------------------------------------------------------------------------
# File loop - read input files, call parser: -i|-m|-c|-r|-e
# ------------------------------------------------------------------------------
processing() {
    local popt="$1" ; shift
    local prfx file dopt work fout last name

    case "$popt" in
        -c)     dopt="-c" ; work="content" ;;
        -e)     work="element" ;;
        -i)     dopt="-m" ; work="index" ;;
        -m)     dopt="-m" ; work="module" ; [ -n "$CEN_OPT_TOOLS" ] && name="tools" ;;
        -r)     dopt="-c" ; work="reference" ;;
    esac
    [ -z "$work" ] && _cen_abort - "$*"

    # file callback: <count> <file>
    ___file() {
        local file="$2"
        filter -- "$file" || return 1           # -i/-x options
        if [ -n "$CEN_OPT_HTML" ] ; then
            if [ "$popt" = "-e" ] ; then
                DAT_OUT_FILE="$CEN_OPT_HTML/${file##*/}.html"
            else
                DAT_OUT_FILE="$CEN_OPT_HTML/${name:-$work}.html"
            fi

            if [ "$CEN_OPT_HTML" = "/dev/stdout" ] ; then
                DAT_OUT_FILE="-"
            elif [ "$popt" = "-e" ] ; then
               if [ "$file" -nt "$DAT_OUT_FILE" -o "$BASH_SOURCE" -nt "$DAT_OUT_FILE" ] ; then
                   message -a $"Generating:" "$DAT_OUT_FILE"
               else
                   trace -a $"Current:    " "$DAT_OUT_FILE" ; return 1
               fi
            elif [ -n "$dopt" ] ; then
                [ "$last" = "$DAT_OUT_FILE" ] || message -a $"Generating:" "$DAT_OUT_FILE"
                last="$DAT_OUT_FILE"
            fi
        fi
        return 0
    }

    [ -n "$CEN_OPT_TOOLS" ] && dopt+=" -p usageparser"
    documentation -s -l $dopt "$work" ___file || return 1   # run list
}

# ------------------------------------------------------------------------------
# The one and only action
# ------------------------------------------------------------------------------
run() {
    local copt flst=() item elem cols=94

    # delete cache data
    if [ -n "$CEN_OPT_DELETE" ] ; then
        serialize -d ; serialize -d -n "$CEN_NAME.stat"
        documentation -d "$CEN_NAME.library.cache"
        documentation -d "$CEN_NAME.tools.cache"
        message -a $"Cache data deleted"
    fi
    [ -n "$CEN_OPT_GENERATE" ] && generate      # make html and quit, no return

    # option dependencies
    [ -n "$CEN_OPT_LIBRARY" -a $# = 0 -a -z "$CEN_OPT_INCLEXCL" ] && CEN_OPT_REFERENCE=1
    [ -n "$CEN_OPT_TOOLS" -a $# = 0 ] && CEN_OPT_MODULES=1
    [ -z "$CEN_OPT_CONTENT$CEN_OPT_INDEX$CEN_OPT_MODULES$CEN_OPT_REFERENCE" ] && elem=1
    [ -n "$CEN_OPT_INDEX$CEN_OPT_MODULES"  ] && copt="-c -m"
    [ -n "$CEN_OPT_CONTENT$CEN_OPT_REFERENCE" ] && copt="-c"

    if [ $# = 0 ] && [ "${#CEN_OPT_INCLEXCL[@]}" = 0 ] && [ -z "$CEN_OPT_USE" ] &&
                     [ -n "$elem" -a -z "$CEN_OPT_HTML" -a -z "$CEN_OPT_ALL" ] ; then
        [ -n "$CEN_OPT_DELETE" ] && quit
        embed -m "_centauri_bash_use" -u    # show usage and quit
    fi

    # alias references to index.html and tools.html and know tools
    splitjoin -x 'eval bookmark -x' -i DAT_BOOKMARK

    # init html output
    if [ -n "$CEN_OPT_HTML" ] ; then
        DAT_FMT_TYPE=html ; elem=1
        # deserialize if not renewing, force renewing on failure
        if [ -z "$CEN_OPT_REFERENCE" ] ; then
            if serialize -q -r ; then
                bookmark -m                 # create prev/next dictionaries
            elif [ -z "$CEN_OPT_TOOLS" ] ; then
                message $"Need to rebuild index files"
                CEN_OPT_REFERENCE=1
            fi
        fi

    # init plain text output
    else
        console -m 3 -c 0
    fi

    # output width
    [ -n "$CEN_OPT_LINES" ] && ((cols += 8))
    [ -n "$CEN_OPT_FILE"  ] && ((cols += 19))
    [ "${CEN_COLS:-0}" = "0" -o "${CEN_COLS:-0}" -gt "$cols" ] && CEN_COLS="$cols"

    if [ $# = 1 ] ; then
        if [ "$1" = "-" ] ; then
            [ -n "$CEN_OPT_TOOLS" ] && CEN_OPT_MODULES=1
            elem= ; set --
        elif [ "$1" = '<pipe>' -a -n "$CEN_OPT_TOOLS" ] ; then
            syspager documentation -p usageparser element '/dev/stdin'
            return
        fi || :
    fi

    # --- make file list ---

    if [ "$CEN_OPT_USE" = "." ] ; then
        flst=("$BASH_SOURCE")
    elif [ -n "$CEN_OPT_USE" ] ; then
        inpfile -c -- "$CEN_OPT_USE" || return
        flst=("$CEN_INPFILE")
    fi

    if [ -n "$CEN_OPT_TOOLS" ] ; then
        folder -f -c "$CEN_TOOLS"
        if [ -z "$CEN_OPT_USE" ] ; then
            flst=(centauri*)
            # add utilities that are part of the library
            for item in "${DAT_UTILS[@]}" ; do
                [ -e "$CEN_ROOT/$item" ] && flst+=("$CEN_ROOT/$item")
            done
        fi
    else
        folder -f -c "$CEN_LIBRARY"
        if [ -z "$CEN_OPT_USE" ] ; then
            flst=(_centauri_bash_???)
            for item in _*_*_usr ; do
                [ -e "$item" ] && flst+=("$item")
            done
        fi
        if [ -n "$CEN_OPT_ALL" ] ; then
            if [ -n "$CEN_OPT_HTML" ] ; then
                [ -e "$CEN_OPT_HTML/index.html"     ] || CEN_OPT_INDEX=1
                [ -e "$CEN_OPT_HTML/module.html"    ] || CEN_OPT_MODULES=1
                [ -e "$CEN_OPT_HTML/content.html"   ] || CEN_OPT_CONTENT=1
                [ -e "$CEN_OPT_HTML/reference.html" ] || CEN_OPT_REFERENCE=1
            else
                CEN_OPT_MODULES=1 ; CEN_OPT_CONTENT=1; CEN_OPT_REFERENCE=1
            fi
        fi
    fi

    # --- generate output ---

    DAT_CNT_FILE="${#flst[@]}"
    [ "$DAT_CNT_FILE" = 0 ] && quit $"No input module found"
    trace -a -p $"Processing %s modules" "$DAT_CNT_FILE"
    includes                                            # create js and css

    ___cache() {
        dryrun $"cache check/update" && return
        if [ -z "$CEN_OPT_TOOLS" ] ; then               # cache enable...
            documentation -s -e "$CEN_NAME.library.cache" ||
                fatal $"Failed to init cache:" "$CEN_NAME.library.cache"
            if [ "${CEN_DOC_APICHANGE:-0}" -gt 0 ] ; then
                trace -a -p $"Must update html index files (stat %s)" "$CEN_DOC_APICHANGE"
                serialize -w -n "$CEN_NAME.stat" CEN_DOC_APICHANGE
            fi
        else                                            # cache enable ...
            documentation -e "$CEN_NAME.tools.cache" -p usageparser ||
                fatal $"Failed to init cache:" "$CEN_NAME.tools.cache"
        fi
    }

    # generate output, loop over files
    ___docs() {
        documentation -s -f $copt -- "${flst[@]}" ||    # set file list
            return
        if [ -n "$CEN_OPT_TOOLS" ] ; then
            DAT_BMK_NEXT[tools]="${flst##*/}"           # for fwd link of tools.htnl
            [ -n "$CEN_OPT_MODULES" -o $# -gt 0 ] && ___cache
        elif [ -n "$CEN_OPT_ALL" ] ||
             [ -n "$CEN_OPT_INDEX$CEN_OPT_MODULES$CEN_OPT_CONTENT$CEN_OPT_REFERENCE" ] ; then
            ___cache
            if [ -n "$CEN_OPT_HTML" ] && serialize -q -r -n "$CEN_NAME.stat" ; then
                message -a $"API change: must update index/modules/content/refence"
                CEN_OPT_INDEX=1   ; CEN_OPT_MODULES=1
                CEN_OPT_CONTENT=1 ; CEN_OPT_REFERENCE=1
                serialize -d -n "$CEN_NAME.stat"
            fi
        elif [ $# -gt 0 ] ; then                        # have filter, need cache
            ___cache
        fi

        [ $# -gt 0 ] && documentation -s -q -- "$@"     # element filter

        [ -n "$CEN_OPT_REFERENCE" ] && processing -r    # must be 1st
        [ -n "$CEN_OPT_INDEX"     ] && processing -i
        [ -n "$CEN_OPT_MODULES"   ] && processing -m
        [ -n "$CEN_OPT_CONTENT"   ] && processing -c
        [ -n "$elem"              ] && processing -e
        documentation -s -x                             # clear list
    }
    syspager ___docs "$@"                               # output (via pager)
}

# ------------------------------------------------------------------------------
# option parsing: <option> <argument>
# ------------------------------------------------------------------------------
options() {
    case "$1" in

    --help) # input completion
        if [ "$2" = "verb" ] && serialize -r ; then
           [ "$3" = "--tools" -o "$3" = "-T" ] && \
                set -- "${DAT_REF_TOOLS[@]}" || set -- "${DAT_REF_FUNCTIONS[@]}"
            local item
            for item in "$@" ; do
                item="${item%%$'\a'*}" ; echo "${item%% *}"
            done
        fi ;;

    "") # end of option processing
        optarg "$CEN_OPT_LIBRARY$CEN_OPT_TOOLS" - -m "--tools --library"
        if [ -n "$CEN_OPT_INDEX$CEN_OPT_MODULES$CEN_OPT_CONTENT$CEN_OPT_REFERENCE" ] ; then
            [ -n "$CEN_OPT_USE" ] &&
                optarg - - -m "--use (--index|--modules|--content|--reference)"
            [ -n "$CEN_OPT_TOOLS" ] &&
                optarg - - -m "--tools (--index|--modules|--content|--reference)"
            CEN_OPT_LIBRARY=
        fi
        if [ -n "$CEN_OPT_INDEX" -a -z "$CEN_OPT_HTML" ] ; then
            CEN_OPT_INDEX= ; CEN_OPT_MODULES=1
        fi
        optarg "$CEN_OPT_TOOLS$CEN_OPT_ALL" - -m "--tools --all"
        if [ -n "$CEN_OPT_HTML" ] ; then
            CEN_OPT_PAGER="no"
            [ -n "$CEN_OPT_LINES$CEN_OPT_FILE" ] && optarg - - -m "--html (--lines|--file)"
        fi
        [ -n "$CEN_OPT_FILE" ] && CEN_OPT_LINES=1
        ;;

    -A|--all*)
        optarg "all"        - ;;
    -C|--con*)
        optarg "content"    - ;;
    -D|--del*)
        optarg "delete"     - ;;
    --fil|--file)
        optarg "file"       - ;;        # show file names
    -G|--gen*)
        optarg "generate"   - "all|too.*|lib.*|dum.*" ;;
    -H|--htm|--html)
        optarg "html"       - -d ;;     # folder
    -I|--ind*)
        optarg "index"      - ;;
    --l10n)
        optarg "l10n"       - ;;
    --lin*)
        optarg "lines"      - ;;        # show line numbers
    -L|--lib*)
        optarg "library"    - ;;
    -M|--mod*)
        optarg "modules"    - ;;
    -R|--ref*)
        optarg "reference"  - ;;
    -T|--too*)
        optarg "tools"      - ;;
    -U|--use)
        optarg "use"        - -t ;;     # text
    esac
}

# ------------------------------------------------------------------------------
# print usage info
# ------------------------------------------------------------------------------
usage() {
    usageset \
        -u "$CEN_NAME [-A] [-C] [-I] [-M] [-R] [-H <folder>] [-N] [-U <file>] ..." \
        -u "$CEN_NAME -T [-H <folder>] [-N] [-U <file>] ..." \
        -u "$CEN_NAME -G <what> [-H <folder>] ..." \
        -u "$CEN_NAME -D ..." \
        -u - \
        -u "$CEN_TITLE." \
        -u - \
        -u $"This tool can generate documentation in HTML format or can be used at" \
        -u $"the command line in text mode (like the linux \"man\" program)."
    usageset \
        -o - \
        -o "-D --delete          "$"delete caches" \
        -o "-G --generate <what> "$"generate HTML documentation" \
        -o "-H --html   <folder> "$"create HTML output in folder     (implies --all)" \
        -o "   --file            "$"text only: output file names     (implies --lines)" \
        -o "   --lines           "$"text only: output line numbers" \
        -o "-L --library         "$"process library documentation (default)" \
        -o "-T --tools           "$"process the usage output of tools" \
        -o "-U --use      <file> "$"process a single file, \"-U .\" for '$CEN_NAME'" \
        -o - \
        -o "-A --all             "$"(re)create missing index/modules/content/reference" \
        -o "-C --content         "$"produce table-of-content" \
        -o "-I --index           "$"html only: create 'index.html'" \
        -o "-M --modules         "$"produce table of modules" \
        -o "-R --reference       "$"produce function/topic reference"
    usageset \
        -l $"arguments" \
        -t "<what>       "$"selection"": all | tools | library | dummy" \
        -t "<folder>     "$"output folder (- for /dev/stdout, + to prompt)" \
        -t "<file>       "$"any tool or library file" \
        -t "" \
        -l $"filters" \
        -t $"All extra command line arguments work as output filters. Any number of" \
        -t $"filters can be used and are cumulative. Tree selectors are provided to" \
        -t $"restrict output to functions '-' or topics '+' or modules '='."
    usageset \
        -l $"examples" \
        -t "# "$"select generated output" \
        -t "$CEN_NAME --content   # output table-of-content" \
        -t "$CEN_NAME --all       # also output index/modules/content/reference" \
        -t "$CEN_NAME -i ext      # only output _centauri_bash_ext documentation" \
        -t "$CEN_NAME folder att  # filter for '*folder*' or '*att*'" \
        -t "$CEN_NAME -M move     # in which module is 'move'" \
        -t "$CEN_NAME -C -i _sys  # what is in module _centauri_bash_sys" \
        -t "$CEN_NAME - sys       # restrict output to functions" \
        -t "" \
        -t "# "$"create the documentation as HTML ('doc' is the destination folder)" \
        -t "$CEN_NAME --delete --all --html doc" \
        -t "" \
        -t "# "$"create/view the documentation as file (--force enables ANSI escapes)" \
        -t "$CEN_NAME --all --force > doc.txt" \
        -t "less -FRX doc.txt" \
        -t "" \
        -t "# "$"generate HTML documentation" \
        -t "$CEN_NAME --generate=tools -H mydir      # tool docs to custom location" \
        -t "$CEN_NAME --delete --generate=all        # clear cache, docs to default"
}

# ------------------------------------------------------------------------------
# Finally call the library to execute the script
# ------------------------------------------------------------------------------
main "$@" ; quit

# the end
