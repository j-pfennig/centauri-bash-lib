#!/usr/bin/bash

# ------------------------------------------------------------------------------
# This tool can be run without centauri-bash-lib being installed. If so it uses
# a couple simplified library equivalents that are created below ...
# ------------------------------------------------------------------------------

[ "${CEN_NAME:--}" = '-' ] && [ -x '/usr/local/bin/_centauri_bash_lib' ] &&
    . /usr/local/bin/_centauri_bash_lib -a -f - '0.01:2' 0

# ------------------------------------------------------------------------------
# Script supporting mini-bash-lib
# ------------------------------------------------------------------------------
run() {
    [ "$#" = 0 ] && { usage ; quit -s 2 ; }

MINIMAL="${MINIMAL:-false}" ####################################################
if $MINIMAL ; then #############################################################
    quit "TODO: your code ..."
else ###########################################################################
    # example code
    if [ -n "$CEN_HOOK_MESSAGE" ] ; then
        message -p "Using centauri-bash-lib version '%s'" "${CEN_MODULES['_centauri_bash_lib']}"
    else
        message "Using mini-bash-lib"
    fi
    quit
fi #############################################################################
}

# ------------------------------------------------------------------------------
# help display
# ------------------------------------------------------------------------------
usage() {
    cat <<!EOF
usage: $CEN_NAME [-v] [-f] [-h] <arg>... 
!EOF
}

# ------------------------------------------------------------------------------
# The mini-bash-lib contains these functions and options ...
# ------------------------------------------------------------------------------
#
#   confirm     -a -i -n -y
#   embed       [no options]
#   error       -a -t -q
#   folder      -c -m -q
#   message     -a -i
#   symlink     -n
#   system      [no options]
#   trace       [all options ignored]
#   quit        -e -s
#
# ------------------------------------------------------------------------------

if [ -z "$CEN_HOOK_MESSAGE" ] ; then                # have no centauri-bash-lib
    CEN_OPT_FORCE=          # option -f
    CEN_OPT_VERB=0          # option -v
    CEN_EXIT=0              # exit code
    CEN_NAME="${BASH_SOURCE##*/}"

    message() {
        [ "$1" = '-a' ] && shift
        if [ "$1" = '-i' ] ; then
            shift ; echo "${CEN_NAME//?/ }  $*"
        else
            echo "$CEN_NAME: $*" >&2
        fi
    }

    trace() {
        [ "$CEN_VERB" -lt 2 ] && return 0
        while [ "${1::1}" = '-' ] ; do shift ; done
        echo "${CEN_NAME//?/ }  $*" >&2
    }

    # simplified error message: [-q|-t] <text>...
    error() {
        case "$1" in
        -a)     shift ;;
        -q)     [ "${CEN_EXIT}" = 0 ] && return 0
                shift ; quit -e "$*" ;;
        -t)     [ "${CEN_EXIT}" = 0 ] && return 0 || return 1
        esac
        echo "$CEN_NAME: ***ERROR***" "$@" >&2
        CEN_EXIT=1 ; return 1
    }

    # yes/no confirm: [-y|-n] [-a|-i] <text>...
    confirm() {
        local oind yesn='[Y/n]' defn=0
        while [ "${1::1}" = '-' ] ; do
            case "$1" in
            --) shift ; break ;;
            -a) ;;
            -i) oind=1 ;;
            -n) yesn='[y/N]' ; defn=1 ;;
            -y) ;;
            esac ; shift
        done

        if [ -n "$oind" ] ; then
            read -p "${CEN_NAME//?/ }  $* $yesn "
        else
            read -p "$CEN_NAME: $* $yesn "
        fi
        [ "${REPLY::1}" = 'y' ] && return 0
        [ "${REPLY::1}" = 'n' ] && return 1
        return "$defn"
    }

    embed() {
        local prog="$1" ; shift
        system "$prog" --embed="$CEN_NAME" "$@"
    }

    folder() {
        local ochg omak oqui
        while [ "${1::1}" = '-' ] ; do
            case "$1" in
            --) shift ; break ;;
            -c) ochg=1 ;;
            -m) omak=1 ;;
            -q) oqui=1 ;;
            esac ; shift
        done
        if [ -d "$1" ] ; then
            [ -z "$ochg" ] && return 0
            system cd "$1" ; return
        elif [ -n "$omak" ] ; then
            system mkdir -p "$1" ; return
        fi
        [ -z "$oqui" ] && error "Not a folder:" "$1"
        return 1
    }

    symlink() {
        local nock
        while [ "${1::1}" = '-' ] ; do
            case "$1" in
            --) shift ; break ;;
            -n) nock='-f' ;;
            esac ; shift
        done
        [ "$1" -ef "$2" ] && return 0
        system ln -s $nock -- "$@"
    }

    system() {
        "$@" && return 0
        error "Running '$1' failed (status $?)"
    }

    quit() {
        case "$1" in
        '')     ;;
        -e)     shift ; error "$*" ;;
        -s)     CEN_EXIT="${2:-2}" ;;
        *)      message "$*"
        esac
        exit "$CEN_EXIT"
    }

    while [ "${1::1}" = '-' ] ; do
        case "$1" in
        -f|--for*)   CEN_OPT_FORCE=1 ; shift ;;
        -h|--help)   usage ; exit 2 ;;
        -v|--ver*)   CEN_VERB=2 ; shift ;;
        *)  break
        esac
    done
    run "$@" ; exit                         # using mini-bash-lib
elif [ -n "$CEN_STAGE" ] ; then
    run "$@"                                # we got sourced
else
    main "$@" ; quit                        # using centauri-bash-lib
fi

# end
