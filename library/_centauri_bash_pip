#!/bin/bash
# ------------------------------------------------------------------------------
# _centauri_bash_pip = Centauri Bash Library Coprocess, Pipe and Pager support
#
# Call:     . _centauri_bash_pip
#
#+General:  The module implements three functions that use pipes (fifo) or
#           the bash coproc command:
#
#,          - [[sysbind()]]  - bind two pipes to a server process, simple RPC calls
#,          - [[syspager()]] - pipe a command's output through a pager (like less)
#,          - [[syspipe()]]  - run a command in background using coproc or a pipe
#
# Copyright Dr. J. Pfennig (c) 2021-2022
# ------------------------------------------------------------------------------

CEN_MODULES['_centauri_bash_pip']='0.02:1'

# ------------------------------------------------------------------------------
# Pager + Using a pager like less or more
#
#+The library supports a pager via the [[_centauri_bash_pip]] module. If this
# module is available at script start time, the option --pager gets enabled
# automatically and all output from [[run()]] or action handlers can be passed
# through a pager this way.
#
#+The easiest method for paging output programmatically (and thereby honoring
# the --pager option) is using the CEN_PAGER variable. On request the option
# parser in [[main()]] will load [[_centauri_bash_pip]] and call [[syspipe()]]:
#
#.      $CEN_PAGER <worker> <arg>...
#
#+The [[syspipe()]] call will set "CEN_PAGER=syspipe" if paging is enabled,
# or clear CEN_PAGER if paging is off. To enable paging when --pager is not
# set, use the following code:
#
#.      embed -q _centauri_bash_pip && syspipe  # load module and enable
#.      $CEN_PAGER <worker> <arg>...
#
#+It is also possible to call [[syspager()]] directly, but this will always
# need to load [[_centauri_bash_pip]]. In such a case packaged scripts must add
# this module to the list of packaged modules. Without the module being packed
# a packaged script will not have the --pager option (see [[uglify]] tool).
#
#+The [[centaurihelp]] program is used internally as a pager by the library
# to implement the command line --help option. Unless "--helpÂ°--pager=off" is
# used, the [[usage()]] function pages the help output through centaurihelp
# to prettify it.
# ------------------------------------------------------------------------------

embed -c '_centauri_bash_ext'           # import on demand

CEN_PIP_BUSY=                           # coproc recursion protection

# ------------------------------------------------------------------------------
# sysbind - bind two pipes to an external server process, simple RPC calls
#
# Call:     sysbind [-e|-f] [-i <inst>] -s [-d <data>] [--] <serv> <arg>...
#           sysbind [-e|-f] [-i <inst>] -c [<name>|-] [-a <rslt>] [-d <data> | [--] <arg>...]
#           sysbind [-e|-f] [-i <inst>] -t
#
# Options:  -a  destination array for RPC reply
#           -i  array to keep state in (default: CEN_SYSBIND)
#           -c  make a RPC call to the server
#           -d  send data to server
#           -e  report errors
#           -f  errors are fatal
#           -s  open pipes (start server)
#           -t  close pipes (terminate server)
#
# Arguments:<arg>   arguments for server
#           <inst>  instance array, not to be modified by caller
#           <rslt>  array to receive server reply
#
# Instance: An array managed by this function, not to be modified by caller
#
#,          inst[0]     process id of server
#,          inst[1]     handle for send pipe
#,          inst[2]     handle for receive pipe
#,          inst[3]     send fifo name (if any)
#,          inst[4]     receive fifo name (if any)
#,          ...         opaque data for internal use
#
# Return:   **true** at success or **false** otherwise.
#
#+The RPC protocol should be text-line based (server replies are split into
# lines, delimiter is "\n"). The server must only send data in reply to a
# request. On each request a reply must be send. Server replies must end with
# a "\n".
# ------------------------------------------------------------------------------
CEN_SYSBIND=
sysbind() {
    #$CEN_DEBUG -c -- "$*"
    local _emsg="$CEN_TRACE" _inam='CEN_SYSBIND' _stat=0 _frun
    while [ "${1::1}" = "-" ] ; do
      case "$1" in
      --)   shift ; break ;;
      -a)   shift ;;
      -i)   shift ; _inam="$1" ;;
      -c)   shift _frun=2;;
      -d)   shift ;;
      -e)   _emsg='error' ;;
      -f)   _emsg='fatal' ;;
      -s)   _frun=1 ;;
      -t)   _frun=0 ;;
      *)    _cen_abort - "$1"
      esac ; shift
    done
    [ -z "$_frun" ] && _cen_abort + '-s|-c|-t'

    local -n _inst="$_inam"

    # close pipes, terminate server
    if [ "$_frun" = 0 ] ; then
        [ -z "$_inst" ] && return 0                     # not initialized
        _inst=()

    # open pipes, start server
    elif [ "$_frun" = 1 ] ; then
        if [ -n "$_inst" ] ; then                       # already initialized
            _emsg -- $"server already initialized" ; return 1
        fi
        _inst=(- - - - -)
        fatal "not implemented"

    # call server
    else
        if [ -z "$_inst" ] ; then                       # not initialized
            _emsg -- $"server not initialized" ; return 1
        fi
        fatal "not implemented"
    fi
    return $_stat
}

# ------------------------------------------------------------------------------
# syspager - pipe a command's output through a pager (like less)
#
# Call:     (1) syspager [-c <cmd>|<path>] [-d] [<func> <arg>...]
#           (2) $CEN_PAGER <func> <arg>...
#
#+          Form (1) initializes CEN_PAGER and CEN_OPT_PAGER. It optionally
#           also runs <func> - directly or via pager. Once initialized,
#           option -c has no effect unless combined with -d.
#
#+          Form (2) runs <func> directly if CEN_PAGER is not set by a
#           command line --pager option or by a prior call to syspager.
#
# Options:  -c  override pager given by CEN_OPT_PAGER
#           -d  clear CEN_PAGER and set CEN_OPT_PAGER='off'
#
# Arguments:<cmd>   pager command: on|off|yes|no|less|more
#           <path>  filesystem path of a pager command
#           <func>  function to be executed
#           <arg>   function argument
#
# Return:   **true** at success or **false** otherwise.
#
#+The implementation of this function uses [[syspipe()]] with default error
# handling. Passing a large amount of data to the pager, so that the pipe
# enters blocking state, and then quitting the pager will cause a SIGPIPE
# error. In turn the error handler will call [[quit()]] so that syspager does
# not return, but quit hooks will run.
# ------------------------------------------------------------------------------
syspager() {
    #$CEN_DEBUG -c -- "$*"
    local _opag="${CEN_OPT_PAGER:-less}"
    while [ "${1::1}" = "-" ] ; do
      case "$1" in
      --)   shift ; break ;;
      -c)   shift ; _opag="${1:-less}" ;;
      -d)   CEN_PAGER= ; CEN_OPT_PAGER='off' ;;
      *)    _cen_abort - "$1"
      esac ; shift
    done

    # initialize paging only if output goes to a terminal
    if [ -z "$CEN_PAGER" -a -n "$TERM" ] && [ -t 1 -a -t 2 ] ; then
        local _plst
        case "$_opag" in
            less|yes|on) _plst=('less' 'more') ;;
            no|off)      _plst='none' ;;
            more)   _plst=('more' 'less') ;;
            *)      _plst=("$CEN_OPT_PAGER" -)
        esac
        if [ "$_plst" = 'none' ] ; then
            :
        elif sysfind -s CEN_OPT_PAGER -- "${_plst[0]}" ; then
            CEN_PAGER='syspager'                   # 1st pager ok
        elif sysfind -s CEN_OPT_PAGER -- "${_plst[1]}" ; then
            CEN_PAGER='syspager'                   # 2nd pager ok
        else
            fatal $"Pager not found:" "$_plst"
        fi
    fi

    [ $# = 0 ] && return 0                  # nothing to run or no pager
    isfunction -e -x -- "$1" || return 1    # need function or command
    if [ -z "$CEN_PAGER" ] ; then
        "$@" ; return
    fi || :

    # run with pager, add some options to pagers
    local _args _sane
    case "${CEN_OPT_PAGER##*/}" in
        true)         _args=("$CEN_TOOLS/centaurihelp" --pager=no --force --tool "<pipe>") ;;
# TODO fixme pager would hang ...
##      true)         _args=($CEN_TOOLS/centaurihelp --force --tool "<pipe>") ;;
        centaurihelp) _args=("$CEN_OPT_PAGER" --tool '<pipe>')
                       [ -n "$CEN_FEATURE_T" ] && _args+=('--l10n')  ;;
        less)         _args=("$CEN_OPT_PAGER" -R -F -X) ;;
        *)            _args=("$CEN_OPT_PAGER") ;;
    esac

    # run pager via syspipe to avoid sub-shell by pipe problem
    _sane="$CEN_QUIT_SANE" ; CEN_QUIT_SANE=1
    if [ -n "$CEN_PACKAGE" ] ; then
        # calling external tool with full path, CEN_ROOT makes no sense here
        CEN_ROOT= syspipe -c 'quit' -n -o "$*" -r -- "${_args[@]}"
    else
        syspipe -c 'quit' -n -o "$*" -r -- "${_args[@]}"
    fi || :
    CEN_QUIT_SANE="$_sane"
}

# ------------------------------------------------------------------------------
# syspipe - run a command in background using coproc or a pipe
#
# Call:     syspipe ORIGIN [DESTINATION] [-c <error>|-]
#                   [-e|-f] [-g] [-n] [-r] [-v] [-x] [-y] -- <cmd> <arg>...
#
#           ORIGIN      := -o <producer> | -i <var> | -i -
#           DESTINATION := -d <consumer> | -a <array> | -s <string>
#
# Options:  -a      [*] put output into an array (overrides -c)
#           -d      [*] destination script function (stdin -> <consumer>)
#           -c      error handler (also called from SIGPIPE trap)
#           -e      error message if check fails, overrides -q, see -n
#           -f      make errors fatal
#           -g      accept command exit status=1 as non-error
#           -i      [*] get input data from array or string (overrides -p)
#           -n      do not check <producer>, <provider> or <cmd>
#           -o      [*] origin script function (<producer> => stdout)
#           -r      ignore dryrun
#           -s      [*] put output into a string variable (overrides -c)
#           -x      run as 'coproc' (can have only one coproc at a time)
#           -y      redirect stderr of <cmd> to stdout
#
#                   [*] These options are mutually exclusive
#
# Arguments:<cmd>       command to be run in background
#           <arg>       command argument(s)
#           <error>     a custom error handler, use "-" to disable error handling
#           <consumer>  [#] script function that produces data for <cmd>
#           <producer>  [#] script function that consumes data from <cmd>
#           <array>     name of an array variable
#           <string>    name of a string variable
#           <var>       name of a string or array veriable
#
#           [#] using external commands possibe but not recommended
#
# Return:   **true** at success or **false** otherwise.
#
#+Coproc:   I/O redirection (and "|" pipes) run the command (or function) in a
#           sub-shell. This makes it difficult to pass lengthy output back to
#           the caller's context. The bash **coproc** builtin (see option -x)
#           can mitigate the problem by passing standard input and output of a
#           command to the caller's context. See the [[extsort()]] function for
#           a **coproc** example.
#
#+          Beware: **coproc** cannot be nested, but the syspipe implementation can run
#           a <producer> / <consumer> pair even without option -x (but at the price
#           of using an temporary file to buffer the <cmd> output).
#
#+Fifo:     A temporary fifo is created via [[tmpfile()]] and the co-process gets
#           its input from a <producer> (or sends its output to a <consumer>) via
#           this fifo. With a <producer> / <consumer> pair a temporary file will be
#           used to capture <cmd> output, and the <consumer> reads input from this
#           file.
#
#+          Fifos can be used in a sub-shell only if [[tmpfile()]] was initialized
#           by the main process.
#
#+Errors:   Error handling in co-processes is challenging. If error handling is not
#           disabled via "-e -" then syspipe registers and clears a handler for SIGPIPE.
#           Because of this and the bash restrictions on **coproc**, this
#           function cannot (or should not) be invoked recursively.
#
#+          The default handler reports an error after SIGPIPE or when <cmd>
#           returns an error. A custom error handler can be provided (like "-e quit"
#           for a silent termination). Here an implementation example:
#
#.          pip_error() {
#.              if [ "$1" = 'STATUS' ] ; then
#.                  error -p $"command failed (status %s): %s" "$2" "$3"
#.              else
#.                  error -p $"command failed (%s): %s" "$1" "$3"
#.              fi
#.              CEN_SYSPIPE=                        # tell producer to stop
#.           }
#
# Examples: (1) fifo: send data through a pager
#.          producer() {
#.              for ((i=0 ; i<100i0; i++)) ; do
#.                 [ -z "$CEN_SYSPIPE" ] && break   # stop after SIGPIPE error
#.                 echo "Hello $i"
#.              done 2>/dev/null                    # hide SIGPIPE error message
#.          }
#.          syspipe -o producer -- less -R -F -X
#
#           (2) fifo: faking coproc (uses a pipe and a temporary file)
#.          syspipe -o producer -a result -- mycommand
#
#           (3) coproc: run external command (tr), capture program output
#.          local linp="Hi there!" lout
#.          syspipe -x -o "echo $linp" -d "read -r lout" -- tr [:lower:] [:upper:]
#.          quit "$lout"
#
#           (4) coproc: in this example _input/_output run in the caller's context
#.          worker() {  local file ; read -r file && system -e -p -z cat "$file" ; }
#.          input()  {  echo "$farg" ; }
#.          output() {  local line ; while read -r line ; do echo "$line" ; done ; }
#.          local farg="/etc/fstab"
#.          syspipe -x -o input -d output -n -- worker
#
#+The implementation allows nested calles to coproc from sub-shells and calls
# involving pipes from the master shell (otherwise pipes would not be removed
# on termination). If these conditions are not met, the script is aborted.
#
#+Variable CEN_SYSPIPE contains the pipe handle(s). The variable can also serve
# as a condition for the <producer> to stop (the error handler clears SIGPIPE).
#
#+It might alse be a good idea to run "context -t +" to catch keyboard
# interrupts. Especially for any <cmd> that executes for long time or creates
# a lot of output.
# ------------------------------------------------------------------------------
CEN_SYSPIPE=
syspipe() {
    #$CEN_DEBUG -c -- "$*"
    local _fcop _fcap _fnoc _fqui \
          _ocal='_cen_pip_error' _odst _oerr _ogra _omsg='error -z' _osrc _oinp _oout _orun
    while [ "${1::1}" = "-" ] ; do
      case "$1" in
      --)   shift ; break ;;
      -a)   shift ; [ "$1" = '-' ] && _oout=2 || _oout=1 ; _ocon="splitjoin -s $1 -i - -l -n" ;;
      -c)   shift ; _ocal="$1" ;;
      -d)   shift ; _oout=0 ; _ocon="$1" ;;
      -e)   _oerr='-e' ;;
      -f)   _oerr='-f' ; _omsg='fatal' ;;
      -g)   _ogra=1 ;;
      -i)   shift ; _oinp="$1" ; _osrc="splitjoin -s - -i $1 -l -n" ;;
      -n)   _fnoc=1 ;;
      -o)   shift ; _osrc="$1" ;;
      -q)   _omsg="$CEN_TRACE" ;;
      -r)   _orun='-r' ;;
      -s)   shift ; _oout=1 ; _ocon="splitjoin -j $1 -i - -l -n" ;;
      -x)   _fcop=1 ;;
      -y)   _fcap=1 ;;
      *)    _cen_abort - "$1"
      esac ; shift
    done

    [ -z "$_osrc$_ocon" ] && _cen_abort + "-i|-o|-d|-a|-s"
    CEN_SYSPIPE=                                # reset state
    local _stat=0 _verb="$CEN_VERB" _acmd=("$@") _cen_pip_temp

    # check cmd and origin/destination
    if [ -z "$_fnoc" ] ; then
        [ -z "$_oerr" -a "$_omsg" != "$CEN_TRACE" ] && _oerr='-e'
        sysfind $_oerr -c -s _cen_pip_temp -- "$_acmd" || return 1
        acmd[0]="$_cen_pip_temp"
        if [ -n "$_osrc" -a -z "$_oinp" ] ; then
            isfunction $_oerr -x -- "${_osrc%% *}" || return 1
        fi
        if [ "$_oout" = 0 ] ; then
            isfunction $_oerr -x -- "${_ocon%% *}" || return 1
        fi
    fi

    # default error handler
    _cen_pip_error() {
        IFS=$' \n\t'                                    # repair IFS
        if [ "$1" = 'STATUS' ] ; then
            [ "$_stat" -gt "${_ogra:-0}" ] &&
                $_omsg -p $"command failed (status %s): %s" "$2" "$3"
        else
            $_omsg -p $"command failed (%s): %s" "$1" "$3"
        fi
        CEN_SYSPIPE=                                    # info for producer
    }

    # special case: stdin (no pipe/coproc, but creates a subshell)
    if [ "$_oinp" = '-' -a "${_oout:-0}" != 0 ] ; then
        if [ "$_oout" = 2 ] ; then
            system -z $_orun -d '--' -n -- "${_acmd[@]}" || _stat=$?
        else
            system -m -s _cen_pip_temp $_orun -d '--' -n -- "${_acmd[@]}" || _stat=$?
            ${_ocon/-i -/-i _cen_pip_temp}
        fi
        [ "${_ocal:--}" != '-' -a "$_stat" != 0 ] && $_ocal 'STATUS' "$_stat" "$_acmd"
        return $_stat
    fi

    [ -z "$_fcop" ] && _cen_pip_temp='[PIPE]' || _cen_pip_temp='[COPROC]'
    dryrun $_orun "$_cen_pip_temp" "${_acmd[@]}" && return 1

    # register a SIGPIPE handler that restores stderr and stdout
    if [ "$_ocal" != '-' ] ; then
        local _herr _hstd; _cen_handle _herr _hstd      # get 2 handles
        eval exec "$_herr>&2 $_hstd>&1"                 # save stderr and stdout
        local _call="CEN_SYSPIPE=; $_ocal SIGPIPE - '$_acmd'; _ocal="
        trap "trap SIGPIPE; exec 1>&$_hstd 2>&$_herr; $_call" SIGPIPE
    fi

    # run command via coproc
    if [ -n "$_fcop" ] ; then
        [ -z "$_osrc" ] && _cen_abort + '-o'
        [ -z "$_ocon" ] && _cen_abort + '-d'
        [ "$CEN_PIP_BUSY" = "$BASHPID" ] && _cen_abort $"coproc already in use" "$BASHPID"
        CEN_PIP_BUSY="$BASHPID"

        if [ -n "$_fcap" ] ; then coproc { "${_acmd[@]}" ; } 2>&1
        else                      coproc { "${_acmd[@]}" ; }
        fi
        local _hout=${COPROC[0]} _hinp=${COPROC[1]} _cpid="$COPROC_PID"
        CEN_SYSPIPE="$_hout $_hinp"
        if [ -n "$_fcap" ] ; then
            $_osrc >&"$_hinp" 2>&1
        else
            $_osrc >&"$_hinp"
        fi
        eval exec "$_hinp"'>&-'                         # producer must close pipe
        [ -r /dev/fd/$_hout ] && $_ocon <&"$_hout"      # consumer needs exiting pipe
        wait $_cpid || _stat=$?
        CEN_PIP_BUSY= ; CEN_SYSPIPE=

    # use a pipe (and optionally a file)
    else
        embed -m '_centauri_bash_ext'                   # for tmpfile

        # helper to run command: "<"|">"|"<>" <command>
        _cen_pip_worker() {
            if [ "$1" = '-' ] ; then
               [ -n "$_fcap" ] && exec 2>&1
               shift
               if isfunction -- "$_acmd" ; then
                    "${_acmd[@]}"
               else
                    exec "${_acmd[@]}"
               fi
            fi

            tmpfile -r -s _pipe[0] -p -f ; CEN_SYSPIPE="$_pipe"
            if [ "$1" = '<>' ] ; then
                tmpfile -r -s _pipe[1] -f ; CEN_SYSPIPE="${_pipe[*]}"
            fi
            [ "$_verb" -gt 1 ] && context -v 1          # disable debug output

            if [ "$1" = '<>' ] ; then
                _cen_pip_worker - <"${_pipe[0]}" >"${_pipe[1]}" &
            elif [ "$1" = '<' ] ; then
                _cen_pip_worker - <"$_pipe" &
            elif [ "$1" = '>' ] ; then
                _cen_pip_worker - >"$_pipe" &
            fi
        }

        local _pwrk _pipe
        if [ -n "$_osrc" -a -n "$_ocon" ] ; then
            _cen_pip_worker '<>' ; _pwrk=$!
            $_osrc >"${_pipe[0]}"                       # this is a fifo
        elif [ -n "$_osrc" ] ; then
            _cen_pip_worker '<' ; _pwrk=$!
            $_osrc >"$_pipe"
        else
           _cen_pip_worker '>' ; _pwrk=$!
           $_ocon <"$_pipe"
        fi
        wait $_pwrk ; _stat=$?
        [ -n "${_pipe[1]}" ] && $_ocon <"${_pipe[1]}"   # this is a file
        [ "$_verb" -gt 1 ] && context -v "$_verb"
        CEN_SYSPIPE=
        remove -r -s -- "${_pipe[@]}"
    fi

    # unregister a SIGPIPE handler
    if [ "$_ocal" != '-' ] ; then
        trap SIGPIPE ; eval exec "$_herr>&- $_hstd>&-"
    fi

    [ "${_ocal:--}" != '-' -a "$_stat" != 0 ] && $_ocal 'STATUS' "$_stat" "$_acmd"
    return $_stat
}

# end
