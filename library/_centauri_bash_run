#!/bin/bash
# ------------------------------------------------------------------------------
# _centauri_bash_run = Centauri Bash Library Configuration related Functions
#
# Call:     . _centauri_bash_run
#
#+Functions in this module are related to the "centauri-bash-lib" configuration
# file and depend on module [[_centauri_bash_iom]], see [[configfile()]].
#
#+Functions:This module implements these public functions:
#
#,          [[launcher()]]   Run an external application using a generic name
#,          [[shortpath()]]  Resolve shortcut names for file system paths
#,          [[terminal()]]   Run a terminal emulator if needed
#
#+Variables:The following public variables are used:
#
#,          CEN_DESKTOP     current desktop or 'tty' if no desktop is detected
#,          CEN_LAUNCHER    default result variable of [[launcher()]]
#,          CEN_SHORTPATH   default result variable of [[shortpath()]]
#,          CEN_TERMINAL    default result variable of [[terminal()]]
#
# Copyright Dr. J. Pfennig (c) 2022
# ------------------------------------------------------------------------------

CEN_MODULES["_centauri_bash_run"]="0.01:1"

embed -c '_centauri_bash_iom'           # reference declaration

# get current desktop, use 'tty' if no desktop is detected

CEN_DESKTOP="${XDG_CURRENT_DESKTOP,,}"
[ -n "$KDE_FULL_SESSION" -o -n "$KDE_SESSION_UID" ] && CEN_DESKTOP='kde'

# cached config sections, see _cen_run_config

CEN_RUN_LAUNCHER=       # config [launcher] lines
CEN_RUN_TERMINAL=       #        [terminal] lines
CEN_RUN_SHORTPATH=      #        [shortpath] lines

# TODO --embed=<name>:<idnt>:<desktop>
# TODO windows -i <mininmal-mode>
# TODO search centauri-bash-lib  also in CEN_ROOT
# TODO quit exit message should use "signal" for exit-code > 128
# TODO terminal -c|-x not really implemented

# builtin logical paths for shortpath()

CEN_SHORTPATH_LIB=(
        "root:$CEN_ROOT:centauritools "$"installation root"
        "library:$CEN_LIBRARY:centauri-bash-lib library "$"files"
        "tools:$CEN_TOOLS:centauritools "$"applications"
        "locale:$CEN_ROOT/locale:centauritools/library "$"translations"
        "default:$CEN_ROOT/default|${CEN_PATHS[2]}/default:centauritools/library "$"configuration files"
        "persistent:$CEN_ROOT/persistent|${CEN_PATHS[4]}:centauritools "$"persistent cache"
        "transient:$CEN_ROOT/transient|${CEN_PATHS[4]}:centauritools "$"volatile cache"
        # cannot use single quote due to uglify limits. Using  unicode apostrophe
        "temporary:$XDG_RUNTIME_DIR|${CEN_PATHS[4]}|$TMPDIR:"$"the userʼs temporary folder"
        )

# function shortpath and terminal drop CEN_RUN_xxx after 1st run

CEN_SHORTPATH_DAT=      # dynamically loaded data
CEN_TERMINAL_DAT=

# ------------------------------------------------------------------------------
# launcher config + Configuration section in centauri-bash-lib
#
#+General:  The [[launcher()]] function reads the (cached) configuration statements
#           to find an executable command (or a function) for a generic name.
#
#+          "$CEN_ROOT/default" is the preferred location for "centauri-bash-lib",
#           see [[configfile()]] for more details.
#
#+Config:   Valid "centauri-bash-lib" configuration lines are:
#
#           # potential real commands for a generic name
#           °°<what>             § <desk> @<func>|<tool>...
#           # set options and arguments of a command to be run
#           °°<what>**:**<tool>  § <arg>...
#           # command is run by a function
#           °°<what>**:**<tool>  § @<func> <arg>...
#           # optional: command not found if sym-linked to <nogo>
#           °°**-ignore:**<tool> § <nogo>
#           # optional: short commad description
#           °°**-info:**<tool>   § <text>
#           # optional: any kind of flags (not used by launcher)
#           °°**-flag:**<tool>   § <arg>...
#           # optional: explicit path(s) of a command
#           °°**-path:**<tool>   § <path>...
#
#           Where place holders are defined as:
#
#           °°<what>        § generic command name
#           °°<desk>        § desktop type filter
#           °°<tool>        § is a command name (not a path)
#           °°<arg>         § any kind of argument
#           °°<func>        § call a (user script) function to run <what>
#           °°<path>        § file system path, bash globbing allowed
#           °°<nogo>        § sym link destination (example: **qtchooser**)
#           °°<text>        § short command description
#
#           Configuration Example:
#.          [launcher]
#.              # desktop apps (- is for any desktop session, must be last)
#.              editor      -       kwrite featherpad
#.              browser     -       unfug firefox falkon qml
#.              kiosk       -       qml falkon sauwetter firefox
#.              terminal    -       @terminal quarkteig
#.
#.              # terminal apps (tty is for non-desktop mode)
#.              editor      tty     nano vim
#.              browser     tty     w3m
#.
#.              # qml needs some care (@launcher_qmlweb creates the qml script)
#.              -ignore:qml         qtchooser
#.              -path:qml           /usr/lib/*/qt5/bin/qml
#.              browser:qml         @launcher_qmlweb 1024 768 1.2
#.              kiosk:qml           @launcher_qmlweb 1000 800 1.2
#.
#.              # command line args
#.              kiosk:firefox       --fullscreen --new-window
#.              browser:firefox     --new-window
#.              kiosk:falkon        --fullscreen --new-window --no-extensions
#.              browser:falkon      --new-window --no-extensions
#.
#.              # info text for generic names (not commands)
#.              info:editor         text editor
#.              info:browser        web browser
#.              info:kiosk          web browser in kiosk mode
#.              info:terminal       terminal emulator
# ------------------------------------------------------------------------------

# ------------------------------------------------------------------------------
# launcher (callback) - Implementing a user defined command
#
# Call:     <func> <option>.. -- <arg>...
#
# Options:  -f  error are fatal
#           -i  information string
#           -m  lauch per exec or in background
#           -o  override desktop status (force running emulator)
#           -q  no error messages
#           -r  ignore --dryrun
#           -t  window title
#           -x  query if command can be run (args: <cmd> <arg...>)
#           -y  session type override
#
#+          The function must ignore all non-option words and all unspecified
#           options before the '--' separator.
#
#.Example:  launcher_my_command() {
#.              local oerr oinf over orun otit mode desk
#.              while [ $# -gt 0 ] ; do
#.              case "$1" in
#.                  --)   shift ; break ;;
#.                  -f)   oerr='-f' ;;
#.                  -i)   shift ; oinf="$1" ;;      # not used in this example
#.                  -m)   shift ; mode="$1" ;;      # not used in this example
#.                  -o)   shift ; over="$1" ;;      # not used in this example
#.                  -q)   oerr='-q' ;;
#.                  -r)   orun='-r' ;;
#.                  -t)   shift ; otit="$1" ;;
#.                  -x)   ochk=1 ;;
#.                  -y)   shift ; desk="$1" ;;      # not used in this example
#.                  *)    continue
#.                  esac ; shift
#.              done
#.
#.              # option -x: check if executable and return status
#.              if [ -n "$ochk" ] ; then
#.                  sysfind -q -c -- 'my-command' || return 1
#.              # run the command
#.              else
#.                  system $oeff $orun -- 'my-command' --tile "$otit" "$@" || return 1
#.              fi
#.              return 0
#.          }
# ------------------------------------------------------------------------------

# ------------------------------------------------------------------------------
# launcher - Run an external application using a generic name
#
# Call:     (1) launcher [-f|-q] [-m <mode>] [-t <titl>] -o <desk> [--] <what> <arg>...
#           (2) launcher [-f|-q] [-t <titl>] -n -o <desk> -a <rslt> [--] <what> <arg>...
#           (3) launcher [-f|-q] -l <lsel> -o <desk> -a <rslt>
#
# Options:  -a  array of resulting command words (default is CEN_LAUNCHER)
#           -f  errors are fatal
#           -i  information string passed to callback
#           -l  [*] get application list
#           -m  launch via exec or in background
#           -n  [*] do not run, return command array
#           -q  no error messages
#           -r  ignore --dryrun
#           -t  window title (supported by [[terminal()]] and callback)
#           -y  override session type
#
#           [*] these options are mutually exclusive
#
# Arguments:<arg>   arguments to be passed to the application
#           <lsel>  0:all  1:session  2:executable
#           <mode>  0:just run   1:exec   2:background   3:disown
#           <rslt>  variable name, receives returned data as array
#           <desk>  "tty", "kde", "lxqt", ... (see $XDG_SESSION_DESKTOP)
#           <titl>  window title text
#           <what>  generic name for a command like "browser" or "editor"
#
# Return:   **true** at success or **false** otherwise.
#
#+This function can select and run an application depending on session type and
# installation status. It depends on configuration entries in "centauri-bash-lib"
# section "[launcher]", see [[launcher config]].
#
#+If the launcher configuration calls an argument function or a command function,
# the final call passes options -f -i -m -q -r -t and -y to the function, see
# [[launcher (callback)]].
#
# Form (1) searches a matching command and runs it. Form (2) does not run the
# command, but returns the command (as an array of words). The configuration
# "-args:<command>" line is expanded via **eval** to unquote words (single quotes
# must be escaped, variable substitutions may work).
#
#+Form (3) can be used to get a list of commands. The list entries are made up
# of four or five fields: <what>°<desk>°<path>|<tool>...°<info>°[<flag>] . The
# fields are delimited by "\a". The <tool>... names are separated by spaces
# (as in the config line). The <flag> field is only present for **-flag:**<what>
# statements.
#
# Examples: (1) Launch browser as independent process
#.          launcher -m 3 -- browser || quit -e - "failed to run browser"
#.          local bpid=$!
#.          if kill -0 $bpid 2>/dev/null ; then
#.              message "Browser is running (PID=$bpid)"
#.          else
#.              message "Browser has stopped"
#.          fi
#
#           (2) Get a list of configured applications
#.          launcher -l 0
#.          local item flds
#.          for item in "${CEN_LAUNCHER[@]}" ; do
#.              splitjoin -s flds -d $'\a' -- "$item"
#.              printf "%-12s  %-6s  %-40s  %s\n" "${flds[@]::4}"
#.          done
# ------------------------------------------------------------------------------
CEN_LAUNCHER=
launcher() {
    $CEN_DEBUG -c -- "$*"
    local _flst _oerr='-e' _ofun='-e' _onot _odsk _orun=() _temp
    local _desk="$CEN_DESKTOP" _warn="_cen_run_config -m launcher" _vnam='CEN_LAUNCHER'

    # do we have an -x option?
    for _temp in "$@" ; do
        case "$_temp" in
            --)     break ;;
            -x)     _cen_run_command "$@" ; return $? ;;
        esac
    done

    while [ "${1::1}" = '-' ] ; do
        case "$1" in
        --)   shift ; break ;;
        -a)   shift ; _vnam="$1" ;;
        -f)   _oerr='-f' ; _ofun='-f' ;;
        -i|-t)
              _orun+=("$1" "$2") ; shift ;;
        -l)   shift ; _flst="$1" ;;
        -m)   shift ; _orun+=('-m' "${1:-0}") ;;
        -n)   _onot=1  ;;
        -q)   _oerr='-q' ; _ofun= ; _warn=':' ;;
        -r)   _orun+=('-r') ;;
        -y)   shift ; _desk="${1:-tty}" ; _odsk="-y $_desk" ;;
        *)    _cen_abort - "$1"
        esac ; shift
    done
    local -n _vres="$_vnam" ; _vres=()

    # fetch configuration for [launcher]
    local _what="$1" _apps _line _skey _sval _name _path _igno _fltr
    local -A _argd _pard _appd _flgd _ifod

    [ -z "$_desk" ] && _desk='tty'
    #$CEN_TRACE2 "launcher: parse:" "$_what" "$_desk"
    _cen_run_config $_oerr 'launcher' || return 1

    # generic-name filtering if not listing
    if [ -n "$_flst" ] ; then
        _what='*'
        [ "$_flst" = 0 ] && _desk=
    fi

    # loop over config lines
    for _line in "${CEN_RUN_LAUNCHER[@]}" ; do
       _skey="${_line%% *}" ; _sval="${_line#* }"
       # $CEN_TRACE2 "launcher: parse:" "($_what) $_line"
       [ -n "$_sval" ] || _skey=                    # need value, flag error

        case "$_skey" in
            *-)
                $_warn -- "$_line" ; continue ;;    # warning, ignore this line
            -ignore:*)
                _pard["$_skey"]="$_sval" ;;
            -info:*)
                [ -n "$_flst" ] && _ifod["${_skey#*:}"]="$_sval" ;;
            -flags:*)
                [ -n "$_flst" ] && _flgd["${_skey#*:}"]="$_sval" ;;
            -path:*)
                sysfind -o -q -s _pard["$_skey"] -- $_sval ;;
            $_what:*)
                _argd["${_skey##*:}"]="$_sval" ;;
            $_what)
                _fltr="${_sval%% *}"                # session name
                if [ -n "$_desk" ] ; then           # session filtering...
                    [ "$_fltr" = '-' -a "$_desk" = 'tty' ] && continue
                    [ "$_fltr" != '-' -a "$_fltr" != "$_desk" ] && continue
                fi
                if [ -z "$_flst" ] ; then           # 1st match only
                    [ -z "$_apps" -o "$_fltr" != '-' ] && _apps=(${_sval#* })
                else                                # list takes all
                    _apps+=("$_skey:$_fltr")
                    _appd["$_skey:$_fltr"]="${_sval#* }"
                fi
                ;;
            [a-z]*[a-z0-9.])                        # looks ok, no warning
                continue ;;
            *)
                $_warn -- "$_line" ; continue ;;    # warning, ignore this line
        esac
    done

    # debug _apps ; debug _appd ; debug _pard

    # return a command list
    if [ -n "$_flst" ] ; then
        local _cen_run_exe
        for _line in "${_apps[@]}" ; do
            _cen_run_exe="${_appd["$_line"]}"           # application name
            [ "$_cen_run_exe" = '.' ] && _cen_run_exe='centaurilauncher'
            if [ "$_flst" -gt 1 ] ; then                # app installed?
                set -f ; set -- $_cen_run_exe ; set +f
                if [ "${1::1}" = '@' ] ; then           # tool function
                    isfunction -c $_ofun -- "${1:1}" -x -y $_odsk || continue
                else                                    # command
                    _cen_run_exe=
                    for _temp in "$@" ; do              # try -path:xxx option
                        _cen_run_exe="${_pard[-path:$_temp]}"
                        [ -x "$_cen_run_exe" ] && break # match, stop search
                    done
                    if [ -z "$_cen_run_exe" ] ; then    # try via PATH
                        sysfind -q -o -s _cen_run_exe -- "$@" || continue
                    fi
                fi
            fi
            _skey="${_line%%:*}" ; _sval="${_line#*:}"
            if [ "$_sval" = '-' -a -n "$_desk" ] ; then # session filter
                [ -n "${_appd["$_skey:$_desk"]}" ] && continue
            fi
            if [ "$_flst" -gt 2 ] ; then
                _vres+=("$_skey")
            else
                _vres+=("$_skey"$'\a'"$_sval"$'\a'"$_cen_run_exe"$'\a'"${_ifod["$_skey"]}")
                _temp="${_flgd["$_skey"]}" ; [ -n "$_temp" ] && _vres+=($'\a'"$_temp")
            fi
        done
        return 0
    fi

    # find an executable command
    for _name in "${_apps[@]}" ; do
        $CEN_TRACE -a "launcher: check:" "$_name"
        # comaand path or command is a function
        _path="${_pard[-path:$_name]}"                  # -path:xxx option
        if [ -n "$_path" ] ; then
            $CEN_TRACE -a "launcher: path :" "$_path"
        elif [ "${_name::1}" = '@' ] ; then             # command function
             isfunction -c -- "${_name:1}" -x $_odsk || continue
            _path="$_name" ; break
        elif [ "$_name" = '.' ] ; then
            _path="$CEN_TOOLS/centaurilauncher"
        else                                            # command
            sysfind -c -q -s _path -- "$_name" || continue
        fi

        # ignore statement
        _igno="${_pard[-ignore:$_name]}"
        if [ -n "$_igno" ] && [ -h "$_path" ] ; then
            if ! prettypath -c -s _temp -q -- "$_path" ; then
                _path= ; continue
            elif [ "${_temp##*/}" = "$_igno" ] ; then
                $CEN_TRACE2 -a "launcher: igno.:" "$_name = $_igno"
                _path= ; continue
            fi
        fi

        # function instead of command arguments
         _temp="${_argd[$_name]}"
         if [ "${_temp::1}" = '@' ] ; then
            _temp="${_temp:1}" ; _temp="${_temp%% *}"
            if ! isfunction -- "$_temp" ; then
                $CEN_TRACE2 -a "launcher: needs:" "$_temp"
                _path= ; continue
            elif ! $_temp -x $_odsk -- "$_path" "${@:2}" ; then
                $CEN_TRACE2 -a "launcher: error:" "$_temp"
                return 1
            fi
         fi
        break
    done

    if [ -z "$_path" ] ; then
        $CEN_TRACE2 -a "launcher: miss :" "$_what"
        return 1
    fi

    # unquote arguments via eval
    _temp="${_argd[$_name]}"
    if ! eval _vres=($_temp) 2>/dev/null ; then
        _vres=($_temp)
        $_warn "Syntax error:" "$_temp"
    fi
    if [ "${_temp::1}" = '@' ] ; then           # argument function
        _vres=("${_temp%% *}" "$_path" "${_vres[@]:1}" "${@:2}")
    else                                        # command or function
        _vres=("$_path" "${_vres[@]}" "${@:2}")
    fi
    [ -n "$_onot" ] && return 0
    _cen_run_command  $_oerr "${_orun[@]}" $_odsk -- "${_vres[@]}" || return $?
    return 0
}

# ------------------------------------------------------------------------------
# shortpath config + Configuration section in centauri-bash-lib
#
#+Format:   The [[shortpath()]] function reads the (cached) configuration statements.
#           A shortcut is a short name that is resolved to the path of an existing
#           folder. Multiple destination paths per shortcut can be given in a list
#           and the 1st existing path is used.
#
#+          Each shortcut definition is stored as a text line made of the literal word
#           **path** followed by three fields of (quoted) text that are separated by
#           spaces (e.g. the fields are bash words):
#
#,          <shortcut> := **path** <name> **"**<paths>**"** **"**<info>**"**
#
#+          No ":" characters must appear in <name> or <paths> fields, they are internally
#           used as field delimiters. The list of paths can contain any number of paths
#           separated by "|" characters:
#
#,          <paths> := <path> [ **|** <path> ] ...
#
#+          Extra spaces are not allowed. Spaces and single quotes must be escaped like
#           "\ " and "\'''". The lines are passed through bash **eval** and can contain
#           variables. "~" expansion also works.
#
#.Example: [shortpath]
#.             path disk       "/mnt/backup/disk|$BACKUPS/disk" "folder for disk archives"
#.             path data       "/mnt/backup/data|$BACKUPS/data" "folder for data archives"
#.             path phys       "/mnt/backup/phys|$BACKUPS/phys" "folder for disk images"
#
#+Builtin:  Some predefined entries are provided by the library iself
#
#.             path root       "$CEN_ROOT"              "centauritools installation root"
#.             path library    "$CEN_LIBRARY"           "centauri-bash-lib library files"
#.             path tools      "$CEN_TOOLS"             "centauritools applications"
#.             path locale     "$CEN_ROOT/locale"       "centauritools/library translations"
#.             path default    "$CEN_ROOT/default|${CEN_PATHS[2]}/default"  "config files"
#.             path persistent "$CEN_ROOT/persistent|${CEN_PATHS[4]}"       "persistent cache"
#.             path transient  "$CEN_ROOT/transient|${CEN_PATHS[4]}"        "volatile cache"
#.             path temporary  "$XDG_RUNTIME_DIR|${CEN_PATHS[4]}|$TMPDIR"   "user tmp folder"
# ------------------------------------------------------------------------------

# ------------------------------------------------------------------------------
# shortpath - Resolve shortcut names for file system paths
#
# Call:     shortpath [-q] [-f] [-e] [-g] [-a <rslt>] [-n <ndir>]
#           shortpath ... [-r] -m <part>                # get matching data
#           shortpath ... [-r] <name>...                # get exact matches
#
# Arguments:<name>  a logical path name (shortcut)
#           <ndir>  **dash**    add a '-' to result list
#                   **empty**   add empty entry (default for option -m)
#                   **ignore**  skip this item, do not report as error
#                   **path**    add the 1st defined path to result list
#           <part>  a prefix to be searched in data
#           <rslt>  result array or variable to be set (default: CEN_SHORTPATH)
#
# Options:  -a  result array or variable
#           -e  generate error messages on query operations
#           -f  make errors fatal
#           -g  ignore unknown shortcut names
#           -m  match prefix, search shortcut table
#           -n  folder-not-present action, see <ndir>
#           -q  do not report problems in config/cache handling
#           -r  return raw string, not a path
#
# Return:   **true** at success or **false** otherwise.
#
#+The function loops over a (chached) list of shorcut definition lines. These are
# loaded at 1st call from "centauri-bash-lib" section "[shortpath]". The format is
# described at [[shortpath°config]]. Each shortcut can have a list of paths and
# the 1st path specifying an existing folder becomes the resulting path.
#
# Examples: (1) get some paths from (abbreviated) shortcuts
#.          shortpath -a rslt -- default persi transient
#
#           (2) like (1) but tolerate unknown shortcuts
#.          shortpath -a rslt -g -- default unknown transient
#
#           (3) load the configuration data and return raw array
#.          shortpath -f -q -a rslt -r -m ""
#.          shortpath -f -q -a part -r -m "auto"
#
#           (4) resolve shortcut, check if unique
#.          shortpath -g -n ignore -m "$part"
#.          case "${#CEN_SHORTPATH[@]}" in
#.              0)  message "Shortcut '$part' has no path" ;;
#.              1)  message "Shortcut '$part' is '$CEN_SHORTPATH'" ;;
#.              *)  error "Shortcut '$part' is ambiguous"
#.          esac
#
#.          (5) list existing shortcuts
#.          shortpath -m "" -n "dash" ; splitjoin -i CEN_SHORTPATH
# ------------------------------------------------------------------------------
CEN_SHORTPATH=
shortpath() {
    local _vres="CEN_SHORTPATH" _emsg='error -z' _stat=0 _fqui _ferr
    local _pref _plen _fgra _fraw _item _name _ndir _isok _full _ndef
    local _oerr='-e' _warn='_cen_run_config -m shortpath'
    while [ "${1::1}" = "-" ] ; do
        case "$1" in
        --)   shift ; break ;;
        -a)   shift ; _vres="$1" ;;
        -e)   _ferr=1 ;;
        -f)   _oerr='-f' ; _emsg="fatal" ;;
        -g)   _fgra=1 ;;
        -m)   shift ; _pref="$1" ; _plen="${#_pref}" ;;
        -n)   shift ; _ndir="$1" ;;
        -q)   _oerr='-q' ; _emsg="$CEN_TRACE" ; _fqui='-q' ; _warn=':' ;;
        -r)   _fraw=1 ;;
        *)    _cen_abort - "$1"
        esac ; shift
    done
    [ -n "$_plen" -a "$#" -gt 0 ] && _cen_abort - "$*"      # -m with arg list
    local -n _vvar="$_vres" ; _vvar=()

    # read configuration file on 1st call
    if [ -z "$CEN_SHORTPATH_DAT" ] ; then
        _cen_run_config $_oerr 'shortpath' || return 1
        local _line ## _args
        for _line in "${CEN_RUN_SHORTPATH[@]}" ; do
            #$CEN_TRACE2 -a "shortpath: parse:" "$_line"
            local _skey="${_line%% *}" _sval="${_line#* }"
            if [ "$_skey" != 'path' ] ; then
                $_warn -- $"1st argument must be 'path':" "$_line"
                _stat=1 ; continue
            fi
            set -f                                          # no file globbing
            if eval trimjoin -d : $_sval &>/dev/null ; then # handle vars and quotes
                set +f ; CEN_SHORTPATH_DAT+=("$CEN_TRIMJOIN")
            else
                set +f ; _stat=2 ; $_warn -- $"syntax error:" "$_line"
            fi
        done
        unset CEN_RUN_SHORTPATH                             # drop config data
        [ -z "${#CEN_SHORTPATH_DAT[@]}" ] && CEN_SHORTPATH_DAT=(-)
    fi

    # error handling
    [ "$_stat" != 0 ] && warning -p $"Error(s) in [%s] configuration: %s" 'shortcut' "$CEN_RUN_CONFIG"
    [ -z "$_plen" -a "$#" = 0 ] && return 0                 # nothing to find
    _stat=0

    # handling of missing entries
    case "$_ndir" in
        "")     _ndef='E' ;;
        dash)   _ndef='-' ;;
        empty)  ;;
        ignore) _ndef='I' ;;
        path)   _ndef='P'  ;;
        *)      _cen_abort - "-n $_ndir"
    esac

    # loop over arguments and data
    while : ; do
        _isok=
        if [ -n "$1" ] ; then                           # match an argument
            _plen="${#1}" ; _pref="$1"
        fi

        for _item in "${CEN_SHORTPATH_LIB[@]}" "${CEN_SHORTPATH_DAT[@]}" ; do
            [ "${_item:--}" = '-' ] && continue         # placeholder
            _full=

            # simple prefix matching, return raw data

            _name="${_item%%:*}"
            if [ -n "$_plen" ] ; then                   # partial match (prefix)
                [ "${_name::_plen}" = "$_pref" ] || continue
            elif [ "$_name" = "$1" ] ; then             # full match
                 _full=1
            elif [ -z "$_fraw" ] ; then                 # ignore if not raw mode
                continue
            fi
            if [ -n "$_fraw" ] ; then                   # return raw data
                [ -z "$_plen" -a -z "$_full" ] && continue
                _isok=2 ; _vvar+=("$_item") ; continue
            fi

            # got match in raw data, get a path

            local _parr
            _item="${_item#*:}" ; _item="${_item%:*}"
            splitjoin -s _parr -d '|' -i _item      # array of alternatives

            for _item in "${_parr[@]}" "" ; do      # loop over alternatives
                [ -z "$_item" ] && continue
                if [ "${_item::3}" = ".. " ] ; then
                    prettypath -c -p -s _item -- "${_item:3}" || continue
                    _item="${_item%/*}"
                elif [ "${_item::1}" = "~" ] ; then
                    _item="${_item// /\\ }"         # escape spaces
                    eval _item=$_item
                fi
                if [ -n "$CEN_PATHS" ] && [ -d "$CEN_PATHS/$_item" ] ; then
                    _item="$CEN_PATHS/$_item" ; break
                fi
                [ -d "$_item" ] && break
            done
            _isok=1

            if [ -z "$_item" ] ; then               # no folder found
                case "$_ndef" in
                    E)  $_emsg $"No folder for shortcut:" "$_name"
                        _stat=1 ; _isok=2 ;;
                    I)  _isok=2 ;;
                    P)  _item="${_parr[0]}" ;;
                    *)  _item="$_ndef" ;;
                esac
            fi

            if [ "$_plen" = 0 ] ; then                  # match all (list)
                _vvar+=("${_item% }")
            elif [ -n "$_plen" ] ; then                 # prefix match
                [ -n "$_item" -o -z "$_ndef" ] && _vvar+=("${_item% }")
            else                                        # exact match
                [ -n "$_item" ] && break
            fi
        done

        # save result or report error

        if [ -n "$_isok" ] ; then                       # save match
            [ -z "$_plen" -a "$_isok" != "2" ] && _vvar+=("${_item% }")
        elif [ -n "$_fraw" ] ; then                     # error for raw data
            if [ -z "$_fgra" ] ; then
                $_emsg $"Not a valid shortcut:" "${1:-$_pref}" ; _stat=1
            fi
        else                                            # got an error ...
            if [ "$_ndef" != 'E' -a -n "$_fgra" ] ; then
                case "$_ndef" in
                E|I) ;;
                P)  _vvar+=('') ;;
                *)  _vvar+=("$_ndef") ;;
                esac
            elif [ -z "$_fgra" ] ; then
                $_emsg $"Not a valid shortcut:" "${1:-$_pref}" ; _stat=1
            fi
        fi
        shift ; [ "$#" = 0 ] && break
    done
    return "$_stat"
}

# ------------------------------------------------------------------------------
# terminal config + Configuration section in centauri-bash-lib
#
#+General: The [[terminal()]] function reads the (cached) configuration statements
#          to find an executable command to be run as a console emulator.
#
#+          "$CEN_ROOT/default" is the preferred location for "centauri-bash-lib",
#           see [[configfile]] for more details.
#
#+Config:   Valid "centauri-bash-lib" configuration lines are:
#
#           # potential emulator commands
#           °°**emulator**       § <desk> <tool>...
#           # optional: emulator tool configuration
#           °°**-args:**<tool>   § <arg>...
#           °°**-flags:**<tool>  § <arg>...
#           °°**-title:**<tool>  § <arg>...
#           # no emulator if we find a login shell
#           °°**login**          § <arg>...
#           # continue search if ancestor is a shell
#           °°**shell**          § <arg>...
#           # need no emulator for these parents ...
#           °°**white**          § <arg>...
#           # needing to launch emulator ...
#           °°**black**          § <arg>...
#                   # no desktop, no xroot
#           °°**black-startup**  § <arg>...
#                   # embedded konsole, check KONSOLE_DBUS_SERVICE
#           °°**black-konsole**  § <arg>...
#
#           Where place holders are defined as:
#
#           °°<tool>        § is a command name (not a path)
#           °°<arg>         § any kind of argument
#
#           Configuration Example:
#
#.      [terminal]
#.              # emulators for KDE/Gnome desktop sessions:
#.              emulator     kde     konsole qterminal gnome-terminal xterm
#.              emulator     gnome   gnome-terminal konsole qterminal xterm
#.              # other session types (must be last emulator line):
#.              emulator     -      qterminal gnome-terminal konsole  xterm
#.
#.              # options for emulators
#.              -args:konsole       --hide-tabbar --hide-menubar --nofork
#.              -title:konsole      --title
#.              -args:gnome-terminal    --hide-menubar --wait --
#.              -title:gnome-terminal   --title
#.
#.              # configure desktop state detection
#.              login               -bash|-dash|-csh|-sh
#.              shell               bash|dash|csh|sh
#.              white               sudo|kdeinit.*\ konsole.*|konsole.*|gnome.*|qterminal|xterm
#.              black               krunner.*|lx.*-session|plasma.*
#.              black-startup       sddm.*|startkde.*|startplasma.*
#.              black-konsole       dolphin.*|kde.*
# ------------------------------------------------------------------------------

# ------------------------------------------------------------------------------
# terminal - Run a terminal emulator if needed
#
# Call:     (1) terminal [-c|-x] [-f|-q] [-o <over>] [-y <desk>]
#           (2) terminal [-f|-q] [-m <mode>] [-o <over>] [-t <titl>] [-y <desl>] [--] <arg>...
#
# Options:  -a  array of resulting command words (default is CEN_TERMINAL)
#           -c  force check if a terminal emulator must be run
#           -f  error are fatal
#           -m  lauch per exec or in background
#           -n  do not run, only return command array
#           -o  override desktop status (force running emulator)
#           -q  no error messages
#           -r  ignore --dryrun
#           -t  window title (if supported by emulator)
#           -x  check if a terminal emulator can be run
#           -y  desktop type override
#
# Arguments:<arg>   arguments passed to emulator via "<tool> -e <arg>..."
#           <desk>  desktop config to use like: tty kde lxqt gnome
#           <mode>  0:wait (default)  1:exec  2:background  3:disown
#           <titl>  window title
#           <over>  0:auto (default)  1:start  2:no start
#
# Return:   **true** at success or **false** otherwise.
#
#           The following variables are set:
#
#,          - CEN_IS_DESKTOP        desktop status, see below
#,          - CEN_RUN_EMULATOR      used terminal emulator like "/usr/bin/konsole"
#,          - CEN_TERMINAL          command to be executed
#
#+The main pupose of this function is to find out if a desktop is active and
# if the caller is running in a ''terminal'' emulator window. Depending on this
# the following happens:
#
#,          °°Desktop running, no emulator: start an emulator
#,          °°No desktop or in an emulator: simply execute
#
#+Common ''terminal'' emulators are: **konsole**, **qterminal** or **gnome-terminal**.
# The emulator detection process and the emulator to be started can be configured,
# see below.
#
#+The variable CEN_IS_DESKTOP is set on the first call or if option -c is passed:
#
#,          °°CEN_IS_DESKTOP=       # state unknown, will check
#,          °°CEN_IS_DESKTOP=0      # no desktop or in emulator
#,          °°CEN_IS_DESKTOP=1      # have desktop need emulator
#,          °°CEN_IS_DESKTOP=2      # have no desktop but need emulator
#
#+All common terminal emulators seen to support command line option "-e" that is
# followed by a list of arguments that are to be executed in a shell.
#
# Examples: xxx
#
#.          terminal -c             # check only, do not run
#.          terminal                # open a terminal (desktop only)
#.          terminal -- top         # run a program, wait for exit
#
# ------------------------------------------------------------------------------
CEN_RUN_EMULATOR=
CEN_TERMINAL=
terminal() {
    #$CEN_DEBUG -c -- "$*"
    local _bash _ochk _oerr='-e' _onot _orun _otit _over _mode=0 _stat=0 \
           _desk="$CEN_DESKTOP" _vnam='CEN_TERMINAL'
    local _warn='_cen_run_config -m terminal'
    while [ "${1::1}" = "-" ] ; do
        case "$1" in
        --)   shift ; break ;;
        -a)   shift ; _vnam="$1" ;;
        -b)   _bash=1 ;;
        -c)   _ochk=1 ;;
        -e)   ;;                        # ignore, passed from launcher
        -f)   _oerr='-f' ;;
        -m)   shift ; _mode="${1:-0}" ;;
        -n)   _onot=1 ;;
        -o)   shift ; _over="$1" ;;
        -q)   _oerr='-q' ;;
        -r)   _orun='-r' ;;
        -t)   shift ; _otit="$1" ;;
        -x)   _ochk=2 ;;
        -y)   shift ; _desk="$1" ;;
        *)    _cen_abort - "$1"
        esac ; shift
    done
    local -n _acmd="$_vnam" ; _acmd=()


[ "$_ochk" = 2 ] && return 0
    [ -z "$CEN_DISPLAY" ] && CEN_IS_DESKTOP=0
    [ -n "$CEN_IS_DESKTOP" -a "$_ochk" = 1 ] && return 0    # valid status
    [ -z "$CEN_DISPLAY"    -a "$_ochk" = 2 ] && return 1    # cannot run emulator

    # read configuration
    if [ -z "$CEN_TERMINAL_DAT" ] ; then
        _cen_run_config $_oerr 'launcher' || return 1

        local _line _temp _indx
        [ -z "$_desk" ] && _desk='tty'
        #$CEN_TRACE2 "terminal: parse  :" "$_desk"

        for _line in "${CEN_RUN_TERMINAL[@]}" ; do
            local _skey="${_line%% *}" _sval="${_line#* }"
            #$CEN_TRACE2 -a -p "%-12s %s\n" "$_skey" "$_sval"
            [ -z "$_sval" ] && _skey=                   # no argument -> incrorrect

            _indx=
            case "$_skey" in
                emulator)
                    [ -n "$CEN_RUN_EMULATOR" ] && continue
                    _temp="${_sval%% *}" ; _temp="${_temp,,}"
                    [ "$_temp" = '-' -o "$_temp" = "$_desk" ] || continue
                    if ! sysfind $_oerr -o -s CEN_RUN_EMULATOR -- ${_sval#* } ; then
                        _stat=2 ; break
                    fi
                    CEN_TERMINAL_DAT[0]="${CEN_RUN_EMULATOR##*/}"
                    #$CEN_TRACE2 -a "terminal: session: $_temp: $CEN_RUN_EMULATOR"
                    ;;
                -args:*)
                    [ "$_skey" = "-args:$CEN_TERMINAL_DAT" ] || continue
                    _indx=1 ;;
                -flags:*)
                    [ "$_skey" = "-flags:$CEN_TERMINAL_DAT" ] || continue
                    _indx=2 ;;
                -title:*)
                    [ "$_skey" = "-title:$CEN_TERMINAL_DAT" ] || continue
                    _indx=3 ;;
                login)
                    _indx=4 ;;
                shell)
                    _indx=5 ;;
                white)
                    _indx=6 ;;
                black)
                    _indx=7 ;;
                black-startup)
                    _indx=8 ;;
                black-konsole)
                    _indx=9 ;;
                *)  $_warn -- "$_line" ; _stat=1    # warning, ignore this line
            esac
            if [ -n "$_indx" ] ; then
                CEN_TERMINAL_DAT[_indx]="$_sval"
                #$CEN_TRACE2 -a -p "terminal: %-7s: %s" "${_skey%%-*}" "$_sval"
            fi
        done
        unset CEN_RUN_TERMINAL                      # drop config data
        [ -z "$CEN_TERMINAL_DAT" ] && CEN_TERMINAL_DAT=(-)
        if [ "$_stat" = 1 ] ; then
            warning -p $"Error(s) in [%s] configuration: %s" 'terminal' "$CEN_RUN_CONFIG"
        elif [ "$_stat" != 0 ] ; then
            return 1
        fi
    fi

    # check if a terminal emulator should be run: CEN_IS_DESKTOP 0:no  1:yes  2:startup
    if [ "$CEN_TERMINAL_DAT" = '-' ] && [ -n "$_ochk" -a $# != 0 ] ; then
        warning $"No terminal configuration, see:" "$CEN_RUN_CONFIG"
        CEN_IS_DESKTOP=1
    fi

    if [ -z "$CEN_DISPLAY" ] ; then
        $CEN_TRACE $"No desktop running, see $DISPLAY or $XDG_SESSION_DESKTOP"
        CEN_IS_DESKTOP=0
    fi

[ "$_ochk" = 2 ] && return 0

    # index [0]    session          type of desktop session
    #       [1]    args             command option arguments
    #       [2]    flags            flags (not used by launcher)
    #       [3]    title            option set set app title
    #       [4]    login            login shells
    #       [5]    shell            shells
    #       [6]    white            white list
    #       [7]    black            black lisst
    #       [8]    black-startup    no desktop session, no xroot window
    #       [9]    black-konsole    special kde for sub-window

    if [ -z "$CEN_IS_DESKTOP" ] ; then
        CEN_IS_DESKTOP=0
        local _pcmd _ppid="$PPID" _xxxx
        while [ -n "$CEN_DISPLAY" ] ; do
            local _pcmd="/proc/$_ppid/cmdline" ; [ -r "$_pcmd" ] || break
            read -r -d '' _pcmd <"$_pcmd"
            [ "${_pcmd::1}" = "/" -o "${_pcmd::2}" = "./" ] && _pcmd="${_pcmd##*/}" ;
            $CEN_TRACE2 -a "terminal: PARENT=$_pcmd"

            # login: no emulator needed
            if [[ "$_pcmd" =~ ^(${CEN_TERMINAL_DAT[4]})$ ]] ; then
                :

            # shell: loop until other parent than a shell
            elif [[ "$_pcmd" =~ ^(${CEN_TERMINAL_DAT[5]})$ ]] ; then
                [ -r "/proc/$_ppid/stat" ] &&
                    read _xxxx _xxxx _xxxx _ppid _xxxx </proc/$_ppid/stat
                if [ -z "$_xxxx" ] ; then
                    system -r -s _ppid -- ps -p $_ppid -o ppid= || break
                    _ppid="${_ppid// /}" ;
                fi
                [ "${_ppid:-1}" = 1 ] || continue

            # white: we need no emulator
            elif [[ "$_pcmd" =~ ^(${CEN_TERMINAL_DAT[6]})$ ]] ; then
                :

            # black-konsole: must not launch emulator in sub-window
            elif [[ "$_pcmd" =~ ^(${CEN_TERMINAL_DAT[9]})$ ]] ; then
                [ -z "$KONSOLE_DBUS_SERVICE" ] && CEN_IS_DESKTOP=1
            # black-startup: must launch emulator without desktop
            elif [[ "$_pcmd" =~ ^(${CEN_TERMINAL_DAT[8]})$ ]] ; then
                CEN_IS_DESKTOP=2
            # black: must launch emulator
            elif [[ "$_pcmd" =~ ^(${CEN_TERMINAL_DAT[7]})$ ]] ; then
                    CEN_IS_DESKTOP=1

            # don't know, don't launch a konsole
            elif [ "$CEN_VERB" -gt 2 ] ; then
                system -r -q -- logger -t "centauri_bash_lib" "terminal: PARENT=$_pcmd"
            fi
            break
        done
    fi
    $CEN_TRACE2 -a "terminal: CEN_IS_DESKTOP=$CEN_IS_DESKTOP"
    [ -n "$_ochk" ] && return 0

    # no emulator or shell, just run

    local _strt="$CEN_IS_DESKTOP" _xopt _sepa='-e'
    [ "$_over" = 1 ] && _strt=1
    [ "$_over" = 2 ] && _strt=0

    if [ "$_strt" = 0 ] ; then
        [ "$#" = 0 ] && _acmd=(bash -i)
        _acmd+=("$@")
    else

    # build console command
        set -f ; _acmd=("$CEN_RUN_EMULATOR" ${CEN_TERMINAL_DAT[1]}) ; set +f
        if [ "${_acmd[-1]}" = '--' ] ; then
            unset _acmd[-1] ; _sepa='--'
        fi
    #    [ -n "${CEN_TERMINAL_DAT[2]}" ] &&                  # no fork option
    #        _acmd+=("${CEN_TERMINAL_DAT[2]}")
        if [ -n "$_otit" -a -n "${CEN_TERMINAL_DAT[3]}" ] ; then
            [ "$_otit" = '-' ] && _otit="$CEN_NAME"
            _acmd+=("${CEN_TERMINAL_DAT[3]}" "$_otit")      # title option
        fi
        if [ -n "$_bash" ] ; then                           # run bash
            sysfind -c -e -s _bash -- bash || return 1
            _acmd+=("$_sepa" "$_bash")
            [ $# = 0 ] && _acmd+=(-i) || _acmd+=(-c "${*@E}")
        elif [ $# != 0 ] ; then                             # just start
            _acmd+=("$_sepa" "$@")
        fi
    fi

    # execute emulator auto=0  exec=1  background=2   disown=3
    [ -n "$_onot" ] && return 0
    _cen_run_command -m "$_mode" $_oerr $_orun -- "${_acmd[@]}" || _stat=$?
    return $_stat
}

# ------------------------------------------------------------------------------
# use system to run a command: -m <mode> -t <title> -y <desk> <opt>... -- <ag>...
#
# The '--' separator is required, all parameters befor are options or option args.
# The 1st argument must be a full path (starts with /) or a function (starts with @)
#
# mode: 0=just run   1=exec (no return)  2=background   3=disown
# ------------------------------------------------------------------------------
_cen_run_command() {
    $CEN_DEBUG -c -- "$@"
    local _stat=0 _mode=0 _oerr _opts=()
    while [ $# -gt 0 ] ; do
        case "$1" in
        --)   shift ; break ;;
        -m)   shift ; _mode="${1:-0}" ;;
        -t)   shift ; [ -n "$1" ] && _opts+=('-t' "$1") ;;
        -x)   ;;
        -e|-f|-w)
              _opts+=("$1") ; _oerr="$1" ;;
        *)    _opts+=("$1") ;;
        esac ; shift
    done

    case "$_mode${1::1}" in
    0/) system -n "${_opts[@]}" -- "$@" || _stat=$?
        ;;
    1/) quit -h                             # must run hooks before exec
        system $_oerr -n -q -x -- "$@" || _stat=$?
        ;;
    2/) system $_oerr -n -q -x -- "$@" & _stat=$?
        ;;
    3/) system $_oerr -n -q -x -- "$@" & _stat=$? ; disown -h $!
        ;;
    [0-3]@)
         [ "$1" = '@terminal' ] && _opts+=('-o' 1)
         ${1:1} "${_opts[@]}" -m "$_mode" -- "${@:2}" || _stat=$?
         ;;
    *)   _cen_abort - "-m $_mode ... $1 ..."
    esac
    return $?
}

# ------------------------------------------------------------------------------
# Read library configuration: [-f|-q] [-a|-l|-r] <reader> <section>
#                             [-m] [<info>] <line>
# ------------------------------------------------------------------------------
CEN_RUN_CONFIG=
_cen_run_config() {
    local _ferr _read _ropt _fcch _fqui _stat=0 _smsg _path='centauri-bash-lib'
    while [ "${1::1}" = "-" ] ; do
        case "$1" in
        --)   shift ; break ;;
        -a|-l|-r)
              _ropt="$1" ; shift ; _read="$1" ;;
        -e)    ;;
        -f)   _ferr='-f' ;;
        -m)   shift ; _smsg="$1" ;;
        -p)   shift ; _path="$1" ;;
        -q)   _ferr='-q' ; _fqui='-q' ;;
        *)    _cen_abort - "$1"
        esac ; shift
    done

    # error messages
    if [ -n "$_smsg" ] ; then
        CEN_CONFIGFILE=("$CEN_RUN_CONFIG" "$1" - -)
        [ $# = 1 ] && shift
        configfile -w "$_smsg" "$@" ; return 0
    fi

    # cached sections
    case "$1" in
    launcher|terminal|shortpath)
        _fcch=1 ;;
    esac

    if [ -z "$_fcch" -o $# -gt 1 ] ; then
        [ -z "$_read" ] && _cen_abort + '-a|-l|-r'
        configfile -i true -p $_ropt $_read -n "$_path" -- "$@" || _stat=$?
    elif [ -z "$CEN_RUN_CONFIG" ] ; then
        if ! cachefile $_ferr -s -w 'centauri-bash-lib.dat' "$_path" ; then
            configfile $_fqui -r CEN_RUN_LAUNCHER -v -c -n "$CEN_CONFIGFILE" 'launcher'
            configfile $_fqui -r CEN_RUN_TERMINAL -v -c -n "$CEN_CONFIGFILE" 'terminal'
            configfile $_fqui -r CEN_RUN_SHORTPATH -v -c -n "$CEN_CONFIGFILE" 'shortpath'
            CEN_RUN_CONFIG="$CEN_CONFIGFILE"
            serialize $_ferr -w -n "$CEN_CACHEFILE" -m 664 -- CEN_RUN_CONFIG \
                      CEN_RUN_LAUNCHER CEN_RUN_TERMINAL CEN_RUN_SHORTPATH
        fi
    fi
    return $_stat
}

# ------------------------------------------------------------------------------
# Generate library proxy
# ------------------------------------------------------------------------------
_cen_run_proxy() {
    local _repo _rexp _prox
    _rexp="${CEN_PATH_REXP[@]@A}" ; _rexp="${_rexp#declare -* }"

    _cen_run_proxy_rdr() {
        _prox+="$1"$'\n'
    }
    _cen_run_config -r _cen_run_proxy_rdr 'proxy' || :

    [ -n "$_rexp" ] && _rexp=$'\n'"# path replacements from [library] section"$'\n'"$_rexp"
    [ -n "$_prox" ] && _prox=$'\n'"# things from [proxy] section"$'\n'"$_prox"
    create -c -t -w "$CEN_TOOLS/_centauri_bash_lib" <<!EOF || return 1
# --- Proxy for _centauri_bash_lib (autogenerated, see centauri-bash-lib) ---

# installation defaults: <root>:<bin>:<tools>)
CEN_INSTALL="${CEN_INSTALL:-$CEN_ROOT}"

# find the library root folder
if [ "\${CEN_ROOT:-.}" = "." ] ; then
    export CEN_ROOT="\${CEN_INSTALL%%:*}"
    export CEN_TOOLS="\$CEN_ROOT/tools"
    if [ ! "\$CEN_TOOLS/_centauri_bash_lib" -ef "\$BASH_SOURCE" ] ; then
        CEN_TOOLS=\$(readlink -f "\$(type -p _centauri_bash_lib)")
        CEN_TOOLS="\${CEN_TOOLS%/*}" ; CEN_ROOT="\${CEN_TOOLS%/*}"
    fi
elif [ -z "\$CEN_TOOLS" ] ; then
    export CEN_TOOLS="\$CEN_ROOT/tools"
fi
export CEN_LIBRARY="\$CEN_ROOT/library"

# paths that can be installation dependent
CEN_PATHS=("$CEN_PATHS" "${CEN_PATHS[1]}" "${CEN_PATHS[2]}" "${CEN_PATHS[3]}" "${CEN_PATHS[4]}")
$_rexp$_prox

# sanitize environment (bash needs TMPDIR)
[ -z "\$TMPDIR" ] && export TMPDIR="\${XDG_RUNTIME_DIR:-\${CEN_PATHS[4]:-/tmp}}" ;
[ -z "\$TMP" ] || export TMP="\$TMPDIR"

# load real lib, use packed version if newer
if [ "\$CEN_LIBRARY/_centauri_bash_lib.p" -nt "\$CEN_LIBRARY/_centauri_bash_lib" ] ; then
    . \$CEN_LIBRARY/_centauri_bash_lib.p "\$@" || exit 2
else
    . \$CEN_LIBRARY/_centauri_bash_lib "\$@" || exit 2
fi

# init transient folder after boot (root only)
[ "\$EUID" = "0" ] && [ ! -d "\$CEN_ROOT/transient" ] && embed -m "_centauri_bash_sys"
:
!EOF
    sysrun -e -p -- chmod 775 "$CEN_TOOLS/_centauri_bash_lib" || :
    return 0
}

# end
