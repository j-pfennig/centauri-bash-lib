#!/bin/bash
# ------------------------------------------------------------------------------
# _centauri_bash_ext = centauri-bash-lib: Filesystem extension
#
# Call:     . _centauri_bash_ext
#
# Options:  -none-
#
#+Some functions of this module call GNU coreutils like **ln**, **mv**, **rm** and
# others. Their installation folder is usually "/usr/bin" or "/bin". In this
# documentation "/usr/bin" is used, although the "${CEN_PATHS[1]}" variable (corebin)
# is checked by [[system()]] and [[sysrun()]] to find the real location of binaries.
# **CEN_PATHS[1]** can be set to any other folder, depending on the installation,
# see [[library proxy]] and [[folder()]].
#
#+In many cases **ln**, **rm**, **rmdir**, **mkdir** bash builtins can be used
# to avoid starting extra processes for external commands. See the [[autoload]]
# documentation. Most functions notably [[move()]], [[remove()]], [[rename()]]
# and [[symlink()]] are aware of these builtins.
#
# Copyright Dr. J. Pfennig (c) 2016-2022
# ------------------------------------------------------------------------------

CEN_MODULES["_centauri_bash_ext"]="0.22:1"

CEN_EXT_TEMP=               # temp file base path, see tmpfile
CEN_EXT_TIDX=               # ... auto index
CEN_EXT_TPID=               # ... subshell pid
CEN_EXT_REALP=              # 0:=use external  1:=use realpath builtin

# ------------------------------------------------------------------------------
# get logical path (into <logi>): [-e] [-e] <logi> <path>
#
# Options:  -e  check for <path> existing
#           -p  try to generate absolute paths using PWD
# ------------------------------------------------------------------------------
_cen_path_pretty() {
    local _fchk _vnam _fpwd
    while [ "${1::1}" = "-" ] ; do
      case "$1" in
      --)   shift ; break ;;
      -e)   _fchk=1 ;;
      -p)   _fpwd=1 ;;
      *)    _cen_abort - "$1"
      esac ; shift
    done

    local -n _vcpp="$1" ; shift ; _vcpp="$1"
    while true ; do
        case "$_vcpp" in

        # simple cases and some of their aliases
        ""|/)           return 0 ;;
        .|./)           _vcpp="." ; [ -z "$_fpwd" ] && return 0
                        _vcpp="$PWD" ; return 0 ;;
        ..|../)         _vcpp=".." ; [ -z "$_fpwd" ] && return 0
                        _vcpp="${PWD%/*}"
                        [ -z "$_vcpp" ] && _vcpp="/" ; return 0 ;;
        //|/.|/..)      _vcpp="/" ; return 0 ;;

        # remove redundant elements
        ./*)            _vcpp="${_vcpp:2}" ; [ -n "$_fpwd" ] && _vcpp="$PWD/$_vcpp" ;;
        //*)            _vcpp="${_vcpp:1}" ;;
        */)             _vcpp="${_vcpp::-1}" ;;
        */.)            _vcpp="${_vcpp::-2}" ;;
        */./*|/./*)     _vcpp="${_vcpp/\/.\//\/}" ;;
        *//*)           _vcpp="${_vcpp/\/\//\/}" ;;

        # parent (this must be last in case)
        ../*)           [ -z "$_fpwd" ] && break
                        _vcpp="${PWD%/*}${_vcpp:2}" ; break ;;

        *)              [ -z "$_fpwd" -o "${_vcpp::1}" = "/" ] && break
                        _vcpp="$PWD/$_vcpp" ; break
        esac
    done

    [ -z "$_fchk" ] && return 0
    [ "$1" -ef "$_vcpp" ]               # return status
}

# ------------------------------------------------------------------------------
# regex replace path (in _logi): <filter> <path> (path must exist)
# ------------------------------------------------------------------------------
_cen_path_regex() {
    # check candidate against path
    _cen_path_regck() {
        #echo "MATCH $1"
        local _path="$1" _item _iarg=1
        for _item in "${BASH_REMATCH[@]:1}" ; do
            #echo "ITEM $_iarg $_item"
            _path="${_path//%$_iarg/$_item}"
            ((_iarg += 1))
        done
        [ "$_logi" -ef "$_path" ] || return 1
        _logi="$_path" ; return 0
    }

    # pre-checks
    local _fltr="$1" ; _logi="$2"
    case "$_logi" in
        /)      return 0 ;;
        /*/)    _logi="${_logi::-1}" ;;
        /*)     ;;
        *)      return 0
    esac
    [ -e "$_logi" ] || return 0

    # loop over regular expressions
    local _item _path _sifs="$IFS"
    set -f
    for _item in "${CEN_PATH_REXP[@]}" ; do
        IFS=$'\a' ; set -- $_item ; IFS="$_sifs"
        [ "$_fltr" = "$1" ] || continue
        [[ "$_logi" =~ $2 ]] || continue
        shift 2
        for _path in  "$@" ; do         # loop over paths
            _cen_path_regck "$_path" || continue
            _item= ; break
        done
        [ -z "$_item" ] && break
    done
    set +f ; return 0
}

# ------------------------------------------------------------------------------
# Left trim path (in _logi): <trim> [<path>]
# ------------------------------------------------------------------------------
_cen_path_ltrim() {
    [ -n "$2" ] && _logi="$2"
    [ -z "$1" ] && return 1
    if [ "$1" = "$2" ] ; then       # same paths -> .
        _logi="." ; return 0
    fi
    local _leng="${#1}"
    [ "${_logi:_leng:1}" = "/" ] || return 1
    [ "${_logi::_leng}" = "$1" ] || return 1
    _logi="${_logi:_leng+1}" ; return 0
}

# ------------------------------------------------------------------------------
# Get full path, canonicalize, read link: -a|-c|-l <path>
# ------------------------------------------------------------------------------
_cen_path_realp() {
    local _exro _retr _rslt _opta

    case "$CEN_EXT_REALP$1" in

    # run commands or builins
    0-a)    _exro+=(realpath -s) ;;                     # cannot use readlink here
    1-a)    _exro+=(realpath -s) ; _opta=1 ; _retr=1 ;; # fails for all invalid links

    0-c)    _exro+=(readlink -m) ;;
    1-c)    _exro+=(realpath) ; _opta=1 ; _retr=1  ;;   # fails for all invalid links

    ?-l)    [ -e "$2" ] && _exro+=(readlink) || _exro+=(readlink -m) ;;

    # check if builtin can be loaded
    -*)     CEN_EXT_REALP=0
            if [ -n "$CEN_FEATURE_A" ] ; then
                # set cache and flag if builtin can be loaded
                if _cen_dyn_builtin 'realpath' >/dev/null ; then
                    CEN_COMMANDS['realpath']='-' ;CEN_EXT_REALP=1
                fi
            fi
            _cen_path_realp "$@"
            return ;;
      *)    _cen_abort - "$CEN_EXT_REALP$_olow"
    esac

    if [ -n "$_opta" ] ; then                   # direct call...
        _exro+=(-q -a _rslt -- "$2")
        [ "$CEN_VERB" -gt 1 ] && dryrun -r "builtin" "${_exro[@]}"
        builtin "${_exro[@]}" &>/dev/null && _retr=0
    else
        sysrun -q -r -a _rslt -b "${_exro[@]}" -- "$2" && _retr=0
    fi

    # retry with readlink -m as fallback
    if [ "$_retr" = 1 ] ; then
        sysrun -q -r -a _rslt -b -- readlink -m -- "$2" && _retr=0
    fi

    if [ "$_retr" = 0 ] ; then                  # success: set _logi
        _logi="$_rslt" ; return 0
    else                                        # failure: clear _logi
        _logi= ; return 1
    fi
}

# ------------------------------------------------------------------------------
# attributes - Create file/folder, set file/folder attributes
#
# Call:     attributes [-o <owner>|-] [-m <mode>|-] [-c|-d] [-f] [-k] [-r] [-s]
#                      [-x <excl>]... [--] <item>...
#
# Options:  -c  create non-exsting items as files
#           -d  create non-exsting itmes as directories
#           -f  make errors fatal
#           -k  keep existing items unchanged
#           -o  set owner (use **-** for "$LOGNAME:")
#           -m  set mode  (use **-** for **664** or **775**)
#           -r  ignore --dryrun
#           -s  recurse into sub-folders
#           -x  exclude matching arguments, repeatable
#
# Arguments:<mode>   item mode to be set in any **/usr/bin/chmod** syntax
#           <owner>  item owner to be set in **/usr/bin/chown** syntax
#           <excl>   exclude pattern for bash glob
#
# Return:   **true** at success or **false** otherwise.
#
# Examples: (1) Create file or folders
#.          attributes -c "hallo"
#.          attributes -c -o root:staff -m 770 "/.hidden"
#.          attributes -d -o daemon -m - "/run/x1" "/run/x2"
#
#           (2) Set owner/mode recursively
#.          attributes -s -m "o-w" "/etc"
#.          attributes -d -s -m 700 -o root "/etc/test"
#
#           (3) Exclude patterns
#.          attributes -x "*.p" -x "*~" -m 664 library/_*
#
#+The **/usr/bin/chown** program uses a '<user>:[<group>]' notation for owner. With
# '<user>**:**' (no group but trailing colon) the user's primary group is used.
# ------------------------------------------------------------------------------
attributes() {
    local _excl=() _erun _kind _ownr=":" _mode _mdef="664" _args=() _item _srec _ferr="-e"
    while [ "${1::1}" = "-" ] ; do
        case "$1" in
        --)   shift ; break ;;
        -c)   _kind=" " ;;
        -d)   _kind="-d" ; _mdef="775" ;;
        -f)   _ferr="-f" ;;
        -k)   _keep=1 ;;
        -o)   shift ; _ownr="$1" ;;
        -m)   shift ; _mode="$1" ;;
        -r)   _fdry='-r' ;;
        -s)   _srec="-R" ;;
        -x)   shift ; _excl+=("$1") ;;
        *)    _cen_abort - "$1"
        esac ; shift
    done

    for _item in "$@" ; do
        if [ -e "$_item" ] ; then
            [ -n "$_keep" ] && continue
        elif [ -n "$_kind" ] ; then
            create $_fdry $_kind -- "$_item" || continue
        else
            $CEN_TRACE -a $"No such file/folder:" "$_item" ; continue
        fi
        if [ "${#_excl[@]}" = 0 ] ; then    # no excludes...
            _args+=("$_item") ; continue
        fi
        for _erun in "${_excl[@]}" ; do
            [[ "$_item" == $_erun ]] || continue
            _item= ; break
        done
        [ -n "$_item" ] && _args+=("$_item")
    done

    [ -n "$_args" ] || return 0
    [ "${_ownr:--}" = "-" ] && _ownr="${LOGNAME:-$USER}:"
    [ "$_mode" = "-" ] && _mode="$_mdef"
    [ -n "$_mode" ] && sysrun $_fdry $_ferr -b -p -- chmod $_srec "$_mode" -- "${_args[@]}"
    [ "${_ownr:-:}" = ":" ] || sysrun $_fdry $_ferr -b -p -- chown $_srec "$_ownr" -- "${_args[@]}"
}

# ------------------------------------------------------------------------------
# copy - Copy files/folders using coreutils /usr/bin/cp
#
# Call:     copy <opt>... <source>... <dest>
#
# Options:  -a  recurse/archive (**/usr/bin/cp -a**)
#           -f  make errors fatal
#           -o  try ''copy-on-write'' (**/usr/bin/cp** --reflink=auto)
#           -q  do not report errors
#           -r  ignore --dryrun
#           -s  no trace messages
#           -u  update (**/usr/bin/cp** -u)
#           -v  generate messages (default is trace)
#           -x  remove destination before ''copy'' (**/usr/bin/rm** -r)
#
# Return:   **true** at success or **false** otherwise.
#
#+This is a conviniency wrapper for coreutils **/usr/bin/cp** that provides some
# extra reporting and error handling.
# ------------------------------------------------------------------------------
copy() {
    local _oerr="-e -p" _omsg="$CEN_TRACE" _oarc _ocow _oflg _oupd _olis _odes _orem
    while [ "${1::1}" = "-" ] ; do
      case "$1" in
      --)   shift ; break ;;
      -a)   _oarc="-a" ;;
      -f)   _oerr="-f -p" ; _oflg="-f" ;;
      -o)   _ocow="--reflink=auto" ;;
      -q)   _oerr="-q" ; _oflg="-q" ;;
      -r)   _orun="-r" ;;
      -s)   _omsg=: ;;
      -u)   _oupd="-u" ;;
      -v)   _omsg=message ;;
      -x)   _orem=1 ;;
      *)    _cen_abort - "$1"
      esac ; shift
    done
    if [ $# = 2 ] ; then
        _olis="$1" ; _odes="$2"
    elif [ $# -lt 2 ] ; then
        _cen_abort $"Missing arg(s)"
    else
        _olis=("${@:1:$#-1}") ; _odes="${@:$#}"
        if [ ! -d "$_odes" ] ; then
            $_omsg $"Copy destination is not a folder"": $_odes" ; return 2
        fi
    fi
    if [ -n "$_orem" ] && [ -e "$_odes" ] ; then
        $_omsg -a $"Removing destination before copy"": $_odes"
        remove $_orun $_oflg -d -- "$_odes" || return 1     # may use builtins
    fi
    if [ $# -gt 2 ] ; then
        $_omsg -a -p $"Copying %d item(s) to '%s'" "${#_olis[*]}" "$_odes"
    else
        $_omsg -a -p $"Copying '%s' to '%s'" "${_olis[*]}" "$_odes"
    fi
    sysrun $_oerr $_orun -b -- cp $_oarc $_ocow $_oupd -- "${_olis[@]}" "$_odes" && return 0
    [ -n "$CEN_OPT_DRYRUN" ]                     # --dryrun always returns 0
}

# ------------------------------------------------------------------------------
# joinpath - Build a path name from components
#
# Call:     joinpath [-s <rslt>] [-n] [-e <extn>] <elem>...
#
# Options:  -c  canonicalize path (using **/usr/bin/readlink**)
#           -d  add extension only as default
#           -e  add extension (ignored if "."), see [[suffixpath()]]
#           -p  prettify path, see [[prettypath()]]
#           -r  all elements are relative
#           -s  save result to <rslt> (default is CEN_JOINPATH)
#
#.Examples: joinpath    /base more    # =>  /base/more
#.          joinpath    /base /more   # =>  /more
#.          joinpath -r /base /more   # =>  /base/more
#
#.          joinpath    -e xml /dir file       # =>  /dir/file.xml
#.          joinpath    -e xml /dir file.html  # =>  /dir/file.html.xml
#.          joinpath -d -e xml /dir file.html  # =>  /dir/file.html
# ------------------------------------------------------------------------------
CEN_JOINPATH=
joinpath() {
    local _fset="CEN_JOINPATH" _oabs _orel _opre _odef _opte _path _elem
    while [ "${1::1}" = "-" ] ; do
      case "$1" in
      --)   shift ; break ;;
      -a)   _oabs=1 ;;
      -c)   _opre="-q -c" ;;
      -d)   _odef="-d" ;;
      -e)   shift ; _opte="$1" ;;
      -p)   _opre="-q" ;;
      -r)   _orel=1 ;;
      -s)   shift ; _fset="$1" ;;
      *)    _cen_abort - "$1"
      esac ; shift
    done
    local -n _varg="$_fset" ; _varg=

    while [ "$#" -gt 0 ] ; do
        if [ -z "$1" ] ; then
            :
        elif [ -z "$_path" ] ; then
            _path="$1"
        elif [ "${1::2}" = "./" ] ; then
            if [ -n "$_oabs" ] ; then
                _path+="${1:1}"
            elif [ -z "$_orel" ] ; then
                _path="${1:2}"
            else
                _path+="/$1"
            fi
        elif [ "${1::1}" = "/" ] ; then
            [ -z "$_orel" ] && _path=
            _path+="$1"
        else
            _path+="/$1"
        fi ; shift ; [ "$_path" = "/" ] || _path="${_path%/}"
    done

    _path="${_path//\/\//\/}"           # //  => /
    _path="${_path//\/.\//\/}"          # /./ => /

    [ "${_opte:-.}" != "." ] && suffixpath -s _path $_odef -- "$_opte"

    _path="${_path:-.}"
    [ -n "$_opre" ] && prettypath $_opre -s _path -- "$_path"
    _varg="$_path"
}

# ------------------------------------------------------------------------------
# listsearch - search a word in a list
#
# Call:     listsearch [-b] [-c] [-d <deli>] [-m|-n <vres>] [-g|-u|-x] [--] <what> <list>
#           listsearch [-b] [-c] [-m|-n <vres>] [-g|-u|-x] [--] <what> <item>...
#           listsearch [-b] [-c] [-d <deli>] [-m|-n <vres>] [-g|-u|-x] -i <vinp> [--] <what>
#
# Options:  -b  [-] do a binary search (list must be ordered lexically)
#           -c      do a case sensitive search
#           -d      list item separator(s), calls [[splitjoin]] on <list>
#           -g      glob expression match (longest expression wins)
#           -i      input from variable (string or array)
#           -m      return matched word in <vres>
#           -n      return match index in <vres>
#           -u      partial word search, match must be unique
#           -x      regular expression match (longest expression wins)
#
#           [-] Not yet implemented
#
# Arguments:<deli>  word delimiters in list string
#           <vres>  variable to receive the search result
#           <vinp>  variable or array containing the list to be searched
#           <item>  a list item
#           <list>  a list string
#           <what>  the word to be searched
#
# Return:   0   word found
#           1   word not found
#           2   no unique match
#
#.Example:  set -- "oTTO" "emil o* *TO O?* *"
#.          local valn valm
#.          listsearch -g -d ' ' -n valn -m valm -- "$@" || quit "not found"
#.          message "Index $valn is '$valm'"
# ------------------------------------------------------------------------------
listsearch() {
    local _fbin _fcas _fglo _finp _fwrd _fidx _frex _funi _sdel _word _list _curr
    while [ "${1::1}" = "-" ] ; do
      case "$1" in
      --)   shift ; break ;;
      -b)   _fbin=1 ;;
      -c)   _fcas=1 ;;
      -d)   shift ; _sdel="$1" ;;
      -g)   _fglo=0 ;;
      -i)   shift ; local -n _vinp="$1" ; _finp=1 ;;
      -n)   shift ; local -n _vidx="$1" ; _vidx= ; _fidx=1 ;;
      -m)   shift ; local -n _vres="$1" ; _vres= ; _fwrd=1 ;;
      -u)   _funi=1 ;;
      -x)   _fglo=0 ; _frex=1 ;;
      *)    _cen_abort - "$1"
      esac ; shift
    done

    # get input into _list
    [ -z "$_fcas" ] && _word="${1,,}" || _word="$1" ; shift
    [ -n "$_finp" ] && set -- "${_vinp[@]}"
    if [ -n "$_sdel" ] ; then
        splitjoin -s _list -d "$_sdel" -- "$@"
    else
        _list=("$@")
    fi

    # iteration limits
    local _ibeg=0 _iend="${#_list[@]}" _irun
    for ((_irun=_ibeg; _irun<_iend; _irun++)) ; do
        [ -z "$_fcas" ] && _curr="${_list[_irun],,}" || _curr="${_list[_irun]}"
        if [ -n "$_fglo" ] ; then                   # glob match ...
            [ $_fglo -ge ${#_curr} ] && continue    # find longest match
            if [ -n "$_frex" ] ; then               # regexp match
                [[ "$_curr" =~ $_word ]] || continue
            else                                    # glob match
                [[ "$_curr" == $_word ]] || continue
            fi
            [ -n "$_fidx" ] && _vidx="$_irun"
            [ -n "$_fwrd" ] && _vres="${_list[_irun]}"
            _fglo=${#_curr} ; _funi=2
        elif [ -z "$_funi" ] ; then                 # full match only...
            [ "$_word" = "$_curr" ] || continue
            [ -n "$_fidx" ] && _vidx="$_irun"
            [ -n "$_fwrd" ] && _vres="${_list[_irun]}"
            return 0
        else                                        # allow partial match...
            [ "${_curr#$_word}" = "$_curr" ] && continue
            [ "$_funi" = 2 ] && return 2            # previous match, stop
            [ -n "$_fidx" ] && _vidx="$_irun"
            [ -n "$_fwrd" ] && _vres="${_list[_irun]}"
            ((_funi += 1))                          # _funi=2 is one match
        fi
    done
    [ "$_funi" = 2 ]                                # return status
}

# ------------------------------------------------------------------------------
# move - Move (or rename) files or folders using /usr/bin/mv
#
# Call:    move [-f] [-o|-x] [-q|-s|-v] [-r] <src>... <dest>
#
# Options: -f  make errors fatal
#          -o  try to overwrite readonly <dest>
#          -q  do not report errors
#          -r  ignore --dryrun
#          -s  do not report via [[message()]] or [[trace()]]
#          -v  report via [[message()]] (default is [[trace()]])
#          -x  remove destination before ''move'' (implies -o)
#
# Return:  **true** at success or **false** otherwise.
#
#+This is a conviniency wrapper for **/usr/bin/mv** that provides some extra
# reporting and error handling. Unlike [[rename()]] the move function accepts
# multiple <src> arguments if <dest> is a folder.
#
# +Option -o will try to remove a readonly <dest> and option -x will
# unconditionally try to remove <dest>. If more than two arguments are passed
# <dest> must be a folder. In this case -o and -x are disabled.
# ------------------------------------------------------------------------------
move() {
    local _oftl _orep _orun _osys="-e -p" _oerr=error _omsg="$CEN_TRACE"
    while [ "${1::1}" = "-" ] ; do
      case "$1" in
      --)   shift ; break ;;
      -f)   _oftl="-f" ; _osys="-f -p" ; _oerr=fatal ;;
      -o)   _orem=1 ;;
      -q)   _orep="-q" ; _osys="-q" ; _oerr="$CEN_TRACE" ;;
      -r)   _orun="-r" ;;
      -s)   _orep="-s" ; _omsg=: ;;
      -v)   _orep="-v" ; _omsg=message ;;
      -x)   _orem=2 ;;
      *)    _cen_abort - "$1"
      esac ; shift
    done

    local _dest="$2"
    if [ $# -gt 2 ] ; then
        _dest="${@:$#}" ; _orem=                # cannot remove dest folder
        if [ ! -d "$_dest" ] ; then
            $_oerr $"Move destination is not a folder:" "$_dest" ; return 1
        fi
    elif [ $# -lt 2 ] ; then
        _cen_abort $"Missing arg(s)"
    fi

    if [ -e "$_dest" ] ; then
        if [ -z "$_orem" ] ; then
            if [ ! -w "$_dest" ] ; then
                $_oerr $"Move destination not writable:" "$_dest" ; return 1
            fi
        elif [ "$_orem" = 2 ] ; then
            [ "$_osmg" = ":" ] || $CEN_TRACE -a $"Removing destination before move:" "$_dest"
            remove $_oftl $_orun $_orep -d -- "$_dest" || return 1     # may use builtins
        fi
    fi

    $_omsg -a -p $"Moving '%s' to '%s'" "${*:1:$#-1}" "$_dest"

    sysrun $_orun $_osys -b -- mv -f -- "${@:1:$#-1}" "$_dest" && return 0
    [ -n "$CEN_OPT_DRYRUN" ]                     # --dryrun always returns 0
}

# ------------------------------------------------------------------------------
# optmake - Build options string or array
#
# Call:     optmake -s|-j|-a <dest> [-k|-n <name>] [-f|-v|-z] <valu>
#
# Options:  -a  add result to <dest> array
#           -f  option is a flag, no value
#           -j  add result to <dest> variable
#           -k  key name (not an option)
#           -m  do not treat '-' as empty value
#           -s  save result in <dest> variable
#           -n  option name (optionally starting with - or --)
#           -v  option has a value (default is an option flag)
#           -z  option has a value must must be non-zero
#
#.Examples: optmake -a opts -v "$CEN_OPT_INPUT"                 # argument
#.          optmake -a opts -- "-version"                       # constant
#.          optmake -s opts -n host -m -v "$CEN_OPT_HOST"       # text value
#.          optmake -j opts -n logical -f "$CEN_OPT_LOGICAL"    # flag
#.          optmake -a opts -n number  -z "$CEN_OPT_NUMBER"     # num. value
#.          optmake -j opts -n physical   "$CEN_OPT_PHYSICAL"   # flag
#
#.          optmake -j args        -v "$addr"       # add a value
#.          optmake -j args -k mtu -v "$vmtu"       # add key/value
#
#+If the option <name> starts with '-' or '--' the generated code for
# string output (option -j or -s) is:
#
#,    ''-           -<name>   or  -<name> <valu>''     (one or two elements)
#,    ''--          --<name>  or  --<name>=<valu>''    (only one element)
#,    ''default     --<name>  or  --<name> <valu>''    (one or two elements)
#
#+When used with -a option optmake never generates a '=' separator but
# puts the <valu> into an extra array element. For string output only
# simple quoting is used, e.g. '''"''' in <valu> are changed to '''\"'''.
# ------------------------------------------------------------------------------
optmake() {
    local _vset _name _vflg _asep _fmin _valu
    while [ "${1::1}" = "-" ] ; do
      case "$1" in
      --)   shift ; break ;;
      -a)   shift ; _vset="a" ; local -n _vvaa="$1" ;;
      -f)   shift ; _valu="$1" ; _vflg=0 ;;
      -m)   shift ; _fmns=1 ;;
      -j)   shift ; _vset="j" ; local -n _vvaa="$1" ;;
      -k)   shift ; _name="=$1" ;;
      -s)   shift ; _vset="d" ; local -n _vvaa="$1" ; _vvaa= ;;
      -n)   shift ; _name="$1" ;;
      -v)   shift ; _valu="$1" ; _vflg=1 ;;
      -z)   shift ; _valu="$1" ; _vflg=2 ;;
      *)    _cen_abort - "$1"
      esac ; shift
    done

    if [ -z "$_vflg" ] ; then                   # no -f|-v|-z option
        _valu="$1" ; _vflg=0
    fi
    case "$_valu" in
        "") return ;;
        -)  [ -z "$_fmns" ] && return ;;
        0)  [ "$_vflg" = 2 ] && return ;;
    esac

    case "$_name" in
    "")         ;;
    --*)        _asep=1 ;;
    -*)         ;;
    =*)         _name="${_name:1}" ;;
    ?)          _name="-$_name" ;;
    *)          _name="--$_name"
    esac

    # append to array
    if [ "$_vset" = "a" ] ; then
        [ -n "$_name" ] && _vvaa+=("$_name")
        [ "${_vflg:-0}" != 0 ] && _vvaa+=("$_valu")
        [ $# -gt 0 ] && _vvaa+=("$@")

    # simple output string
    else
        _valu="${_valu//\"/\\\"}"
        [ -n "$_vvaa" ] && _vvaa+=" "
        [ -n "$_name" ] && _vvaa+="$_name"
        if [ "${_vflg:-0}" != 0 ] ; then
            if [ -n "$_asep" ] ; then
                _vvaa+="=\"$_valu\""
            else
                [ -n "$_vvaa" ] && _vvaa+=" "
                _vvaa+="\"$_valu\""
            fi
        fi
        [ $# -gt 0 ] && _vvaa+=" $*"
    fi
}

# ------------------------------------------------------------------------------
# pluralize - use singular or plural form depending on count
#
# Call:     (1) pluralize -s <vnam> [-c <caps>] [-n] [-z] [--]
#                         <count> <singular> [<plural> [<zero>|- [<one>|-]]]
#           (2) pluralize [-a|-i] [-e|-f|-w] [-p <frmt> [-c <caps>] [-n] [-z] [--]
#                         <count> <singular> [<plural> [<zero>|- [<one>|-]]]
#
#+          Form (1) saves the singular/plural word to a variable, and form (2)
#           behaves like [[message()]].
#
#+          If no plural is given, the singular with an 's' appended is used.
#           This feature does not make sense with l10n (localization) enabled.
#
# Options:  -c  capitalize 1st letter of singular/plural and count 0/1
#           -n  use numbers with count=0 and count=1
#           -p  format using two arguments: count singular/plural
#           -s  save result to variable (default is calling message)
#           -z  use plural form for zero count
#
# Arguments:<vnam>  a variable name
#           <frmt>  a format string with two '%s' for count/word. The default
#                   format is "%.0s%s", so per default the count gets hidden
#           <caps>  bit 1: capitalize singular/plural  bit 2: cap. count
#           <zero>  optional count=0 text
#           <one>   optional count=1 text
#
#.Example: pluralize -s sout -c 3 -n -z -- "$count" "file" "files"
#.         pluralize -s sout -z -- "$count" "item" "items" "Zero" "Single"
#.         pluralize -a -z -p "Done, %s %s processed" -- "$count" "file" "files"
# ------------------------------------------------------------------------------
pluralize() {
    local _opts=() _caps _numi _zero _word _frmt
    while [ "${1::1}" = "-" ] ; do
      case "$1" in
      --)   shift ; break ;;
      -a|-i|-e|-f|-w)
            _opts+=("$1") ;;
      -c)   shift ; _caps="$1" ;;
      -n)   _numi=1 ;;
      -p)   shift ; _frmt="$1" ;;
      -s)   shift ; _save="$1" ;;
      -z)   _zero=0 ;;
      *)    _cen_abort - "$1"
      esac ; shift
    done
    [ "$#" = 2 ] && set -- "$1" "$2" "$2s"
    [ "$#" -lt 3 ] && _cen_abort "missing args(s)"

    if [ "$1" = 0 ] ; then
        [ -n "$_zero" ] && _word="$3" || _word="$2"
        [ -z "$_numi" ] && _numi=$"zero" || _numi=0
        [ "$_numi" = 'zero' ] && _numi='no'         # fix english translation
        [ "${4:--}" = "-" ] || _numi="$4"
    elif [ "$1" = 1 ] ; then
        _word="$2"
        [ -z "$_numi" ] && _numi=$"one" || _numi=1
        [ "${5:--}" = "-" ] || _numi="$5"
    else
        _word="$3" ; _numi="$1"
    fi
                                                    # capitalize
    [ "$((_caps & 1))" = 1 ] && _word="${_word^}"
    [ "$((_caps & 2))" = 2 ] && _numi="${_numi^}"

    [ "${_frmt:--}" = "-" ] && _frmt="%s %s"        # default format
    if [ -n "$_save" ] ; then
        printf -v "$_save" -- "$_frmt" "$_numi" "$_word"
    else
        message "${_opts[@]}" -p -- "$_frmt" "$_numi" "$_word"
    fi
}

# ------------------------------------------------------------------------------
# prettypath - Get pretty/canonical/real path of a file or folder
#
# Call:      prettypath [-f|-q|-w] [-e] [-s <var>] [-t <trm>]
#                       [-n] [-b] [-c|-l] [-p] [--] [<path>]
#
# Options:  -b  get dirname of argument (strip trailing file name)
#           -c  canonicalize path (return full physical path)
#           -e  <path> must exist
#           -f  errors are made fatal
#           -l  read symlink but do not canonicalize (return logical path)
#           -n  network (abstract) path, see **repath** in **centauri-bash-lib**
#           -p  prettify path, see **repath** in **centauri-bash-lib**
#           -q  output no error messages
#           -s  save path to <var> (default is CEN_PRETTYPATH)
#           -t  trim prefix from result path
#           -w  errors are reported as warnings
#
# Arguments:<path>  the path name to be prettified
#           <var>   prettified path  -or-  empty in failure
#           <trm>   remove any leading <trm>**/** from result <path>s
#
# Return:   **true** at success or **false** otherwise.
#
#+As indicated by it's name the function tries to return pretty path names by
# normalizing and by applying 'repath' expressions. The later are part of the
# library and can be defined in the [library] section of the "centauri-bash-lib"
# configuration file. The data is compiled into the proxy at installation time.
#
#+Repath expressions are 'regular°expressions' that can replace matches in a
# path.
#
#+If option -c is given, the function first uses the **/usr/bin/readlink** to
# resolve any symlinks in the path. Otherwise the path is only normalized (which
# is faster than using -c). This may lead to different results:
#
#.          ln -s /dev/shm /tmp
#.          prettypath       -- /dev/shm/.      # result is: /tmp   (by repath)
#.          prettypath -p    -- /dev/shm/.      # result is: /dev/shm
#.          prettypath -b -c -- /tmp/..         # result is: /dev
#.          prettypath -b    -- /tmp/..         # result is: /
#
#+If option -b, -c or -p are given, the function uses the **/usr/bin/readlink**
# command. Otherwise the function applies some heuristics to prettify the result.
#
# Examples: prettify path, strip working folder path
#.          prettypath -t "$PWD" -- "$1"
#.          message "Path:" "$CEN_PRETTYPATH"
#
#           prettify but do not apply repath expressions
#.          local path
#.          prettypath -p -s path -- "$1"
# ------------------------------------------------------------------------------
CEN_PRETTYPATH=
prettypath() {
    local _ocan _oerr="error" _oexi _obas _otrm _logi _phys
    local _fset="CEN_PRETTYPATH" _fltr="-l"
    while [ "${1::1}" = "-" ] ; do
        case "$1" in
        --)   shift ; break ;;
        -b)   _obas=1 ;;
        -c)   _ocan=2 ;;
        -e)   _oexi=1 ;;
        -f)   _oerr="fatal" ;;
        -l)   _ocan=1 ;;
        -n)   _fltr="-n" ;;
        -p)   _phys=1 ;;
        -q)   _oerr=":" ;;
        -s)   shift ; _fset="$1" ;;
        -t)   shift ; _otrm="$1" ;;
        -w)   _oerr="warning" ;;
        *)    _cen_abort - "$1"
        esac ; shift
    done
    local -n _varg="$_fset" ; [ $# = 0 ] && set -- "$_varg"

    if [ -n "$_oexi" ] ; then
        if [ ! -e "$1" ] ; then
            $_oerr $"No such file or folder:" "$1" ; _varg= ; return 1
        fi
    fi

    if [ "$_ocan" = 1 ] ; then                      # read symlink
        _cen_path_realp -l "$1" && _varg="$_logi"
    elif [ -n "$_ocan" ] ; then                     # canonicalize
        _cen_path_realp -c "$1" && _varg="$_logi"
    else                                            # prettify
        _cen_path_pretty -p "$_fset" "$1"
        if [[ "$_varg" == *..* ]] ; then            # must canonicalize path ...
            _cen_path_realp -a "$1" && _varg="$_logi"
        fi
    fi

    if [ -n "$_obas" ] ; then                       # base folder
        _varg="${_varg%/*}" ; [ -z "$_varg" ] && _varg="/"
    fi

    if [ -z "$_phys" ] ; then                       # apply repath expressions
        _cen_path_regex "$_fltr" "${_varg:-$1}" ; _varg="$_logi"
    fi
    _cen_path_ltrim "$_otrm" "$_varg" && _varg="$_logi"
    return 0
}

# ------------------------------------------------------------------------------
# redirect - Open/close file handle for input/output
#
# Call:     redirect [-q] [-h <num> | -v <var>] -o|-x <file>    # for write
#           redirect [-q] [-h <num> | -v <var>] -a <file>       # for append
#           redirect [-q] [-h <num> | -v <var>] -i <file>       # for read
#           redirect [-q] [-h <num> | -v <var>]                 # close
#           redirect [-q] -f <var>                              # get free handle
#
# Options:  -a  append to output         (<file> **-** for stdout, **+** to prompt)
#           -f  [*] save free handle to <var>
#           -h  [*] use handle <num>
#           -i  redirect input to file   (<file> **-** for stdin,  **+** to prompt)
#           -o  redirect output to file  (<file> **-** for stdout, **+** to prompt)
#           -q  quiet, no error messages
#           -s  do not generate trace messages
#           -v  [*] save/get handle to/from <var>
#           -x  don't ask if output can be overridden
#
#           [*] these options are mutually exclusive
#
# Variables:<file>   file path or "-" or "+"
#           <num>    handle number
#           <var>    variable to save handle
#
#+Return:   **true** at success or **false** otherwise. After a successfull open
#           the variable CEN_REDIRECT contains the canonicalized file path.
#
#.Examples: redirect -h 4 -i /etc/fstab     # open handle 4 for read
#.          read -u 4 ...
#.          redirect -h 4                   # close handle 4
#
#.          redirect -v fhan -o +           # open for write, handle in fhan
#.          echo one >&$fhan                # always use > (it appends)
#.          echo two >&$fhan                # second output line
#.          redirect -v fhan                # closes handle from fhan
#
#+The function can attempt to find a free file handle, but this is not
# thread-safe (bash subshell or co-process).
#
#+The ">>&" cannot be used with handle variables (syntax error). Open the
# handle for append (using -a) and always use the ">&" operator for write.
#
#+Options -a|-i|-o depend on module [[_centauri_bash_iom]] which is loaded
# on demand.
# ------------------------------------------------------------------------------
CEN_REDIRECT=
redirect() {
    local _sinp _sout _ocnt=0 _oapp _ofnd _osav _hndl _oaop='>' _oerr='error -z' _otra="$CEN_TRACE"
    while [ "${1::1}" = "-" ] ; do
      case "$1" in
      --)   shift ; break ;;
      -a)   shift ; _sout="${1:--}" ; _oapp="-a" _oaop=">>" ;;
      -f)   shift ; ((_ocnt += 1)) ; _osav="${1:--}" ; _ofnd=1 ;;
      -h)   shift ; ((_ocnt += 1)) ; _hndl="$1" ;;
      -i)   shift ; _sinp="${1:--}" ;;
      -o)   shift ; _sout="${1:--}" ;;
      -q)   _oerr="$CEN_TRACE" ;;
      -s)   _otra=: ;;
      -v)   shift ; ((_ocnt += 1)) ; _osav="${1:--}" ;;
      -x)   shift ; _sout="${1:--}" ; _oapp="-a" _oaop=">" ;;
      *)    _cen_abort - "$1"
      esac ; shift
    done
    [ "$_ocnt" = 1 ] || _cen_abort - '-f|-h|-v'
    local -n _ovar ; [ -n "$_osav" ] && _ovar="$_osav"

    # close handle
    if [ -z "$_sinp$_sout$_ofnd" ] ; then
        if [ -n "$_osav" ] ; then
            _hndl="$_ovar" ; _ovar=
        fi
        CEN_REDIRECT=
        [ -z "$_hndl" ] && return 0
        [ -e "/dev/fd/$_hndl" ] || return 0
        $_otra -a "redirect:" $"closing file handle:" "$_hndl"
        [ "$CEN_VERB" -gt 2 ] && dryrun -r "exec $_hndl>&-"
        eval exec "$_hndl>&-" ; return
    fi

    # search free handle
    if [ -n "$_ofnd" -o -z "$_hndl" ] ; then
        [ -n "$_osav" ] && _ovar=
        if [ -n "$_hndl" ] ; then
            if [ -e "/dev/fd/$_hndl" ] ; then
                $_oerr -p $"File handle %s is in use" "$_hndl" ; return 1
            fi
        elif [ -z "$_osav" ] ; then
            $_oerr $"Got no variable to save file handle" ; return 1
        else
            _cen_handle _hndl
            $_otra -a "redirect:" $"found file handle:" "$_hndl" "${_sinp:-$_sout}"
            _ovar="$_hndl" ; [ -n "$_ofnd" ] && return 0
        fi
    fi

    # open a file
    [ -n "$_osav" ] && _ovar=
    if [ -n "$_sinp" ] ; then
        CEN_REDIRECT=
        embed -r -m '_centauri_bash_iom'        # uglify: do not pull in the iom module
        inpfile -e -f -l -s CEN_REDIRECT -- "$_sinp" || return 1
        [ "$CEN_VERB" -gt 2 ] &&  dryrun -r "exec $_hndl<$CEN_REDIRECT"
        eval exec "$_hndl<'$CEN_REDIRECT'" || return 1
    elif [ -n "$_sout" ] ; then
        CEN_REDIRECT=
        embed -r -m '_centauri_bash_iom'        # uglify: ...
        outfile $_oapp -f -l -s CEN_REDIRECT -- "$_sout" || return 1
        [ "$CEN_VERB" -gt 2 ] &&  dryrun -r "exec $_hndl$_oaop'$CEN_REDIRECT'"
        eval exec "$_hndl$_oaop'$CEN_REDIRECT'" || return 1
    fi
    [ -n "$_osav" ] && _ovar="$_hndl" ; return 0
}

# ------------------------------------------------------------------------------
# remove - Remove files or folders using rm, rmdir coreutil or builtin
#
# Call:     remove [-d] [-e] [-o] [-r] [-f|-q] [-s|-v] <path>...
#
# Options:  -d  recurse folders (like using "/usr/bin/rm -r")
#           -e  files/dirs must exist (default is "/usr/bin/rm -f")
#           -f  make errors fatal
#           -o  add option **--one-file-system** to **rm** command
#           -q  do not output error messages
#           -r  ignore --dryrun
#           -s  do not report activity via [[trace()]]
#           -v  report via [[message()]] (default is [[trace()]])
#
#+Notes:    Does implicitly ''remove'' a folder (without -d option with a single
#           argument that is a folder):
#
#.          remove <dir>        # (1 arg) will run "/usr/bin/rmdir <dir>"
#.                              # resulting in error for non-empty dir.
#.          remove .. <dir> ..  # (n args) will generate an error by "/usr/bin/rm"
#
# Return:   **true** at success or **false** otherwise.
#
#+This is a conviniency wrapper for **unlink**, **rm** and **rmdir** that provides
# some extra reporting and error handling. The implementation is aware of simple
# cases so that the bash builtins **unlink** and **rmdir** can be used (if enabled
# via [[autoload]]). If the number of arguments is > 1 the function always calls
# **rm** without any further checks.
# ------------------------------------------------------------------------------
remove() {
    local _oerr="-e -p" _orec _ofrc="-f" _oone _orun _omsg="$CEN_TRACE" _oitm=$"file" _smpl
    while [ "${1::1}" = "-" ] ; do
      case "$1" in
      --)   shift ; break ;;
      -d)   _orec="-r" ;;
      -e)   _ofrc= ;;
      -f)   _oerr="-f -p" ;;
      -o)   _oone="--one-file-system" ;;
      -q)   _oerr="-q" ;;
      -r)   _orun="-r" ;;
      -s)   _omsg=: ;;
      -v)   _omsg=message ;;
      *)    _cen_abort - "$1"
      esac ; shift
    done

    # single argument - allow rmdir and unlink bash builtins
    if [ $# = 1 ] ; then
        [ "${1:--}" = "-" ] && return 0
        if [ -h "$1" ] ; then                   # symlink - use unlink
            _oitm=$"symlink" ; _smpl=unlink
        elif [ -d "$1" ] ; then
            _oitm=$"folder"
            [ -z "$_orec" ] && _smpl=rmdir      # non-recursive - use rmdir
        elif [ ! -e "$1" ] ; then
            return 0
        else
            _smpl=unlink                        # simple - use unlink
        fi
    elif [ $# = 0 ] ; then
        return 0
    else                                        # use coreutils remove
        _oitm=$"entries"
    fi
    $_omsg -a -c " $_oitm" -- "$*"

    # bash builtins might be unable to handle options or --
    if [ -n "$_oone" ] ; then
        sysrun $_oerr $_orun -i -- rm $_oone $_orec $_ofrc -- "$@" && return 0
    elif [ -n "$_smpl" ] ; then
        sysrun $_oerr $_orun -d -b -w "$_oitm" \
               -m $"Cannot remove %s: %s" -- $_smpl -- "$1" && return 0
    else
        sysrun $_oerr $_orun -b -- rm $_orec $_ofrc -- "$@" && return 0
    fi
    [ -n "$CEN_OPT_DRYRUN" ]                     # --dryrun always returns 0
}

# ------------------------------------------------------------------------------
# rename - Rename (or move) a file or folder using /usr/bin/mv
#
# Call:    (1) rename [-f] [-o|-x] [-q|-s|-v] [-r] <src> <des>
#          (2) rename [-b <suf>] [-f] [-q|-s|-v] [-r] <src>
#
# Options: -b  make backup '<src>.<suf>' (no <des> argument allowed)
#          -f  make errors fatal
#          -m  source file/folder may be missing (no error message)
#          -o  allow to replace an existing file
#          -q  do not report errors
#          -r  ignore --dryrun
#          -s  do not report via [[message()]] or [[trace()]]
#          -v  report via [[message()]] (default is [[trace()]])
#          -x  allow to replace an existing folder (implies -o)
#
# Return:  **true** at success or **false** otherwise.
#
#+This is a conviniency wrapper for **/usr/bin/mv** that provides some extra
# reporting and error handling. Only one <src> argument is supported and the
# function fails if <des> exists and neither option -o or -x are given.
# ------------------------------------------------------------------------------
rename() {
    local _oftl _omis _orep _orun _osys="-e -p" _oerr=error _omsg="$CEN_TRACE" _suff
    while [ "${1::1}" = "-" ] ; do
      case "$1" in
      --)   shift ; break ;;
      -b)   shift ; _suff="$1" ; _orem=1 ;;
      -f)   _oftl="-f" ; _osys="-f -p" ; _oerr=fatal ;;
      -m)   _omis=1 ;;
      -o)   _orem=1 ;;
      -q)   _orep="-q" ; _osys="-q" ; _oerr="$CEN_TRACE" ;;
      -r)   _orun="-r" ;;
      -s)   _orep="-s" ; _omsg=: ;;
      -v)   _orep="-v" ; _omsg=message ;;
      -x)   _orem=2 ;;
      *)    _cen_abort - "$1"
      esac ; shift
    done

    if [ -n "$_omis" ] ; then
        [ -e "$1" -o -h "$1" ] || return 0
    fi

    local _dest="$2"
    if [ -n "$_suff" -a $# -ge 1 ] ; then
        [ $# -gt 1 ] && _cen_abort $"Extra arg(s)" "$_dest"
        [ -e "$1" ] || return 0
        _dest="$1.$_suff"
    elif [ $# -gt 2 ] ; then
        _cen_abort $"Extra arg(s)" "$*"
    elif [ $# -lt 2 ] ; then
        _cen_abort $"Missing arg(s)"
    fi

    if [ -e "$_dest" ] || [ -h "$_dest" ] ; then
        if [ -z "$_orem" ] ; then
            $_oerr $"Rename destination exists:" "$_dest" ; return 1
        elif [ -d "$_dest" ] ; then
            if [ "$_orem" != 2 ] ; then
                $_oerr $"Rename destination is a folder:" "$_dest" ; return 1
            fi
            [ "$_osmg" = ":" ] || $CEN_TRACE -a $"Removing destination before rename:" "$_dest"
            remove $_oftl $_orun $_orep -d -- "$_dest" || return 1     # may use builtins
        fi
    fi

    $_omsg -a -c " " -- "$1 => $_dest"
    sysrun -b $_orun $_osys -- mv -f -- "$1" "$_dest" && return 0
    [ -n "$CEN_OPT_DRYRUN" ]                     # --dryrun always returns 0
}

# ------------------------------------------------------------------------------
# resolve - Resolve and prettify (multiple) file/dir paths
#
# Call:     resolve [-a <arr>|-s <var>] [-t <trm>] [-e] [-f|-q] [-c|-m] [-p] <path>...
#           resolve [-s <var>] [-e] [-f|-q] [-c|-m] [-p] -x|-y <exe>
#
# Options:  -a  save result to array <arr>
#           -c  canonicalize, ignore missing <path>s
#           -e  error if <path>s does not exist
#           -f  make errors fatal
#           -m  canonicalize, including missing <path>s
#           -s  save result to <var>
#           -t  trim prefix from result paths
#           -f  make errors fatal
#           -p  return pretty name, see [[prettypath()]]
#           -q  do not report errors
#           -x  locate an executable file using BASH_ARGV0
#           -y  locate a file using BASH_ARGV0
#
# Arguments:<path>  any symlink, file or folder. All <path> args are
#           °       resolved at once by a single call to **/usr/bin/readlink**
#           <exe>   name of an executable file or script
#           <arr>   result array
#           <var>   result string (one line per <path>)
#           <trm>   remove any leading <trm>**/** from result <path>s
#
# Return:   **true** at success or **false** otherwise.
#
#+In contrast to [[prettypath()]] this function calls **/usr/bin/readlink**
# (unlesss option -p is used). Also it can pass multiple <path> args at once.
#
#+If option -p is given, the function prettifies the result paths in the same
# way as [[prettypath()]] does. This option overrides option -m and only
# existing paths will be returned.
#
#+Options -x/-y search $CEN_TOOLS, $CEN_LIBRARY and the BASH_ARGV0 basedir.
# A script can use this to get the invocating path or a file in the library
# or the same folder as the invocating path.
#
#.Examples: # check a list and return pretty names (don't call readlink)
#.          resolve -e -m -p -- here/* and/there*
#
#.          # check a list and return resolved paths
#.          resolve -e -m -- here/* and/there*
#
#.          # generate error messages for missing items
#.          resolve -- here/* and/there*    # readlink execution would fail
#.          resolve -e -- here/* and/there* # error message per missing item
#
#.          # get my invokation path
#.          resolve -x -p && message "Path:" "${CEN_RESOLVE%/*}"
# ------------------------------------------------------------------------------
CEN_RESOLVE=
resolve() {
    local _ocan _otrm _oexe _osys='-e -p' _pret \
          _vset="CEN_RESOLVE" _varr _vrrr _xchk _xerr=error _nret=0
    while [ "${1::1}" = "-" ] ; do
      case "$1" in
      --)   shift ; break ;;
      -a)   shift ; _vset= ; local -n _vvaa="$1" ; _vvaa=() ;;
      -c)   _ocan='-e' ;;
      -e)   _xchk=1 ;;
      -f)   _xerr=fatal ; _osys="-f -p" ;;
      -m)   _ocan='-m' ;;
      -p)   _pret=1 ;;
      -q)   _xerr=: ; _osys="-q" ;;
      -s)   shift ; _vset="$1" ; _varr= ;;
      -t)   shift ; _otrm="$1" ;;
      -x)   _oexe=1 ;;
      -y)   _oexe=2 ;;
      *)    _cen_abort - "$1"
      esac ; shift
    done

    # string output, set reference
    if [ -n "$_vset" ] ; then
        local -n _vsss="$_vset" ; _vsss=
    fi

    # get executable - use _centauri_bash_lib paths and resolve argv0 if needed
    if [ -n "$_oexe" ] ; then
        local _logi _self="$CEN_TOOLS:$CEN_LIBRARY:${BASH_ARGV0%/*}"
        PATH="$PATH:$_self" sysrun -q -r -a _logi -- type -f -p -- "$1"
        if [ -z "$_logi" ] ; then
            [ -h "$BASH_ARGV0" ] && _cen_path_realp -c "$BASH_ARGV0"
            _self="${_logi%/*}"
            set -- "${_self:-$PWD}/$1"
            if [ "$_oexe" = 1 ] ; then
                [ -x "$1" ] || _nret=1
            else
                [ -e "$1" ] || _nret=1
            fi
        else
            set -- "$_logi"
        fi
    fi

    # check file list
    if [ -n "$_xchk" ] ; then
        local _file _flst=()
        for _file in "$@" ; do
            if [ -h "$_file" ] || [ -e "$_file" ] ; then
                _flst+=("$_file") ; continue
            fi
            $_xerr $"No such file or folder:" "$_file" ; _nret=1
        done
        set -- "${_flst[@]}"
    fi

    # resolve symlinks
    if [ -n "$_ocan" ] ; then
        if [ $# = 1 ] ; then
            if [ "$_ocan" = '-e' ] && [ ! -e "$1" ] ; then
                $_xerr $"No such file or folder:" "$1" ; return 1
            else
                _cen_path_realp -c "$1" || return 1 ; set -- "$_logi"
            fi
        elif [ $# -gt 1 ] ; then
            sysrun $_osys -a _vrrr -r -- readlink $_ocan -- "$@" || return 1
            set -- "${_vrrr[@]}"
        fi
    fi

    # try to find a nice path names
    if [ -n "$_pret" -o -n "$_otrm" ] ; then
        _vrrr=()
        for _logi in "$@" ; do
            if [ -n "$_pret" ] ; then
                _cen_path_pretty -e -p _logi "$_logi" || continue
            fi
            [ -n "$_otrm" ] && _cen_path_ltrim "$_otrm"
            _vrrr+=("$_logi")
        done
        set -- "${_vrrr[@]}"
    fi

    # join array into string and return status
    if [ -n "$_vset" ] ; then
        splitjoin -j "$_vset" -d "\n" -- "$@"
    else
        _vvaa=("$@")
    fi
    return $_nret
}

# ------------------------------------------------------------------------------
# splitcall - run commands or functions splitting long arguments lists
#
# Call:     splitcall -c|-s <what> [-e|-f|-q] [-g <good>] [-p] [-r]
#           °         <>           [-a <para>] [-m <maxi>] [-d <deli>] -i <data>
#           splitcall -c|-s <what> [-e|-f|-q] [-g <good>] [-r]
#           °         <>           [-a <para>] [-m <maxi>] [-p] [-d <deli>] -- <arg>...
#
# Options:  -a      parameter array, see below
#           -c      call a script function
#           -d  [-] delimiter passed to [[splitjoin()]]
#           -e      add option -e (report errors)
#           -f      add option -f (make errors fatal)
#           -g      stop processing if exit code of <what> is greater <good>
#           -i  [-] input variable name (can be an array)
#           -m      maximum chunk size for parallel processes
#           -p  [-] parallel processing, see below
#           -q      add option -q (no messages)
#           -r      add option -r (ignore --dryrun)
#           -s      use [[sysrun()]] to run a (external) command
#
#           [-]     Not yet implemented
#
# Arguments:<arg>   list of fields that get added to <data>
#           <data>  list to be split into chunks
#           <deli>  used to split strings into items, see [[splitjoin()]]
#           <good>  maximum non-error return code (default is using "error°-t")
#           <what>  a function/command to be invoked for chunks of <data>
#           <para>  parameters passed to <func>, can be string or array, '@'
#           °       stands for a chunk of <data>. If no '@' field is passed,
#           °       it automatically gets appended to <para>.
#           <maxi>  maximum chunk size (default: -c uses 100, -p uses number of cpus)
#           <deli>  field delimiter if <data> is a string, not used for array
#
# Return:   **true** at success or **false** otherwise.
#
#.Examples: # call function: symlink -e -r -- "$@" "dest-folder"
#.          local para("--" "@" "$dest-folder")
#.          splitcall -c symlink -e -r -m 1024 -a para -- "$@"
#
#.          # run a program: sysrun -e -p -r -- mytool --option "$1" "dest"
#.          local para("--option" "@" "$dest")
#.          local arga("tick" "tack" "tock")
#.          splitcall -s "mytool" -e -r -m 1 -a para -i arga
#
#.          # parallel processes: sysrun -- worker "$1"
#.          splitcall -p -s "worker" -- '1.dat' '2.dat' '3.dat'
#
#.          # parallel subshells: wrapper -e -r -- "$1"
#.          splitcall -p -c "wrapper" -e -r -- '1.dat' '2.dat' '3.dat'
# ------------------------------------------------------------------------------
splitcall() {
    local _oerr _vnam _call _deli _fdry _fpre _good _ivar _maxi _ppar _srun
    while [ "${1::1}" = "-" ] ; do
      case "$1" in
      --)   shift ; break ;;
      -a)   shift ; _vnam="$1" ;;
      -c)   shift ; _call="$1" ; isfunction -f -- "$1" ;;
      -d)   shift ; _deli="$1" ;;
      -e)   _oerr='-e' ; _fpre='-p' ;;
      -f)   _oerr='-f' ; _fpre='-p' ;;
      -g)   shift ; _good="$1" ;;
      -i)   shift ; _ivar="$1" ;;
      -m)   shift ; _maxi="$1" ;;
      -p)   _ppar=1 ;;
      -q)   _oerr='-q' ;;
      -r)   _fdry='-r' ;;
      -s)   shift ; local _cen_splitcall
            sysfind -f -s _cen_splitcall -- "$1" ; _srun="$_cen_splitcall" ;;
      *)    _cen_abort - "$1"
      esac ; shift
    done
    [ -z "$_call" -a -z "$_srun" ] && _cen_abort = '-c|-s'

    local _offs= _leng _coun="$#" _aidx _args _stat _save _savd _rval=0
    _leng="${_maxi:-1024}"

    if [ -n "$_vnam" ] ; then                       # find '@' in param list
        listsearch -c -n _aidx -i "$_vnam" -- '@' ||
            _cen_abort $"No '@' in arguments array:" '-a'
        local -n _cen_splitcall="$_vnam"
    fi

    [ -n "$_ppar" ] && fatal -t "Not yet implented:" '-p'
    [ -n "$_deli" ] && fatal -t "Not yet implented:" '-d'
    [ -n "$_ivar" ] && fatal -t "Not yet implented:" '-i'

    if [ "${_good:--}" = '-' ] ; then               # save/reset error state
        _save="$CEN_ERROR" ; _savd="$CEN_DONE"
        error -c
    fi

    while [[ "$_offs" -lt "$_coun" ]] ; do
        if [ -n "$_vnam" ] ; then                   # make argument list
            _args=("${_cen_splitcall[@]::_aidx}")
            _args+=("${@:_offs+1:_leng}")
            _args+=("${_cen_splitcall[@]:_aidx+1}")
        else
            _args=("${@:_offs+1:_leng}")
        fi

        if [ -n "$_srun" ] ; then
            sysrun -n $_fdry $_fpre $_oerr -- "$_srun" "${_args[@]}"
        else
            $_call $_fdry $_oerr "${_args[@]}"
        fi
        _stat="$?" ; ((_offs+=_leng))
        [ "$_stat" = 0 ] && continue

        if [ "${_good:--}" = '-' ] ; then           # stop after any error
            error -t && continue
        elif [ "$_stat" -le "${_good:-0}" ] ; then  # stop if $? > _good
            continue
        fi
        _rval="$_stat" ; break                      # stop with error code
    done || :

    if [ "${_good:--}" = '-' -a "$CEN_ERROR" = '0' ] ; then
        CEN_ERROR="$_save" ; CEN_DONE="$_savd"      # restore error state
    fi
    return $_rval
}

# ------------------------------------------------------------------------------
# spliteval - Split strings using the bash eval builtin
#
# Call:     (1) spliteval -a|-s <var> [-g|-n] [-q|-w] -i <var>
#               spliteval -a|-s <var> [-g|-n] [-q|-w] [--] <data> ...
#           (3) spliteval -u <var> [-g] [-q|-w] -i <var>
#               spliteval -u <var> [-g] [-q|-w] [--] <data> ...
#
# Options:  -a  result array
#           -g  enable bash globbing
#           -i  input from <var>, can be array or string
#           -n  no eval, just smart quoting (use with -s only)
#           -q  do not report eval errors
#           -s  result string (smart quoted)
#           -u  simplified 'unquote' to result array
#           -w  print warning on eval errors
#
#
# Return:   **true** at success or **false** otherwise.
#
#.Examples: # do globbing and eval
#.          local dest=() data=("*.conf" '1st example' "$CEN_PATH/etc")
#.          spliteval -a dest -g -i data
#
#.          # do globbing and eval, smart quoting
#.          local dest data=("*.conf" '1st example' "$CEN_PATH/etc")
#.          spliteval -s dest -g -i data
#
#.          # smart quoting arguments to string
#.          local dest
#.          spliteval -s dest -n -- "*.conf" '1st example' "$CEN_PATH/etc"
#
#.          # simplified unquote of a quoted string
#.          local quot uquo=()
#.          spliteval -s quot -- " one * 'two tree'   four '|'" "\"five\"  \$HOME"
#.          spliteval -u uquo -i quot
# ------------------------------------------------------------------------------
spliteval() {
    local _oinp _oset _oerr=error _oglo _onoe _oset _stat=0
    local -n _vvei _vveo
    while [ "${1::1}" = "-" ] ; do
      case "$1" in
      --)   shift ; break ;;
      -a|-u)
            _oset="$1" ; shift ; _vveo="$1" ; _vveo=() ;;
      -g)   _oglo=1 ;;
      -i)   shift ; _oinp=1 ; _vvei="$1" ;;
      -n)   _onoe=1 ;;
      -q)   _oerr="$CEN_TRACE" ;;
      -s)   _oset="$1" ; shift ; _vveo="$1" ; _vveo= ;;
      -w)   _oerr=warning ;;
      *)    _cen_abort - "$1"
      esac ; shift
    done
    [ -n "$_oinp" ] && set -- "${_vvei[@]}"

    # simple 'unquote' eval, fast path
    if [ "$_oset" = '-u' ] ; then
        if [ -n "$_oglo" ] ; then
            eval _vveo=("$*") ; _stat=$?
        else
            set -f ; eval _vveo=("$*") ; _stat=$? ; set +f
        fi 2>/dev/null
        [ "$_stat" = 0 ] && return 0
        _vveo=("$*")
        $_oerr $"Syntax error:" "$_vveo" ; return 1
    fi
    [ -z "$_oset" ] && _cen_abort = '-a|-s|-u'

    # full eval
    local _line _item _ugly _args=()
    [ -z "$_oglo" ] && set -f
    for _item in "$@" ; do
       # _ugly=
        if [ -n "$_onoe" ] ; then
            _args+=("$_item")
        else
            # fix-ups to make eval happy
            if [ "$_item" != "${_item/[(|)]/}" ] ; then
                _item="${_item//|/\\|}" ; _item="${_item//(/\\(}"
                _item="${_item//)/\\)}" ; _ugly=1
            fi
            # use eval to append to array
            if ! eval _args+=("$_item") 2>/dev/null ; then
                [ -z "$_oglo" ] && set +f
                $_oerr $"Syntax error:" "$_item"
                _args+=("$_item") ; _stat=1
            fi
        fi
    done
    [ -z "$_oglo" ] && set +f

    # smart quoting
    for _item in "${_args[@]}" ; do
        if [ -n "$_ugly" ] ; then                   # undo fix-ups
            _item="${_item//\\\|/|}" ; _item="${_item//\\\(/(}"
            _item="${_item//\\\)/)}"
        fi
        if [ "$_oset" = '-a' ] ; then               # array output
            _vveo+=("$_item")
            continue
        fi
        case "$_item" in                            # smart quoting
        '')     _item="''" ;;
        *[![:alnum:]]*)
                [ -n "${_item//[[:alnum:]-+=_.:@\/\[\]]/}" ] && _item="${_item@Q}" ;;
        esac
        [ -z "$_line" ] && _line="$_item" || _line+=" $_item"
    done
    [ "$_oset" = '-s' ] && _vveo="$_line"
    return $_stat
}

# ------------------------------------------------------------------------------
# splitpath - Split path name into components
#
# Call:     splitpath -a <rslt> [-e] [-f] [-g|-p] [-w] <path>
#
# Options:  -a  result array (parent, base, ext)
#           -f  parent is 1st name part only
#           -e  separate extension
#           -g  separate extensions (greedy)
#           -p  separate parent path (greedy)
#           -w  try to strip "$PWD" from parent
#
# Return:   0: success  1: path is root (no parent)  2: readlink error
#
#+The function does a simple prettify of the path to remove redundant or
# trailing "/" chars or "./" and "/./" . Relative paths are made absolute
# and unnormalized paths like "weird/../path" need to invoke the
# **/usr/bin/readlink** command.
#
#+None of path the components need to exist. Unless option -w is used,
# the returned field 0 (parent) always contains an absolute path otherwise
# it is empty when "$PWD" is the parent.
#
# Examples: results for path '/' '/one' '/one/two' :
#.          splitpath    -p ...  #  =>  ("" "/")    # root has no parent
#.          splitpath    -p ...  #  =>  ("/one" "")
#.          splitpath    -p ...  #  =>  ("/one" "two")
#
#           results for path '/example/base.text' :
#.          splitpath -e -p ...  #  =>  ("/example" "base" "text")
#.          splitpath -e    ...  #  =>  ("/example/base" "text")
#.          splitpath    -p ...  #  =>  ("/example" "base.text")
#
#           results (greedy) for path '/one/two/a.b.c' :
#.          splitpath -e -f ...  #  =>  ("/one/two" "a.b" "c")
#.          splitpath -g -f ...  #  =>  ("/one/two" "a" "b.c")
#.          splitpath    -f ...  #  =>  ("/one/two" "a.b.c")
# ------------------------------------------------------------------------------
# This is a table of examples for options -f or -p and -e:
#   _Input_____ _Output(-f -e)___________________ _Output(-p -e)_________________
#   x           ([0]=""  [1]="x"     [2]="")      ([0]=""     [1]="x"    [2]="")
#   x/y         ([0]="x" [1]="y"     [2]="")      ([0]="x"    [1]="y"    [2]="")
#   x/y/z       ([0]="x" [1]="y/z"   [2]="")      ([0]="x/y"  [1]="z"    [2]="")
#   x/y/z/      ([0]="x" [1]="y/z"   [2]="")      ([0]="x/y"  [1]="z"    [2]="")
#   a.b.c       ([0]=""  [1]="a.b"   [2]="c")     ([0]=""     [1]="a.b"  [2]="c")
#   /a.b        ([0]="/" [1]="a"     [2]="b")     ([0]="/"    [1]="a"    [2]="b")
#   a.b/        ([0]=""  [1]="a.b"   [2]="")      ([0]=""     [1]="a.b"  [2]="")
#   /a.b/       ([0]="/" [1]="a.b"   [2]="")      ([0]="/"    [1]="a.b"  [2]="")
#   /           ([0]=""  [1]="/"     [2]="")      ([0]=""     [1]="/"    [2]="")
#   /x          ([0]="/" [1]="x"     [2]="")      ([0]="/"    [1]="x"    [2]="")
#   /x/y        ([0]="/" [1]="x/y"   [2]="")      ([0]="/x"   [1]="y"    [2]="")
#   /x/y/z      ([0]="/" [1]="x/y/z" [2]="")      ([0]="/x/y" [1]="z"    [2]="")
#   /x/y/z/     ([0]="/" [1]="x/y/z" [2]="")      ([0]="/x/y" [1]="z"    [2]="")
# ------------------------------------------------------------------------------
splitpath() {
    local _vset _oext _odmy _opar _left _righ _path _ofir _ospl _owrk _pref
    while [ "${1::1}" = "-" ] ; do
      case "$1" in
      --)   shift ; break ;;
      -a)   shift ; _vset="$1" ; local -n _vvaa="$1" ; _vvaa=() ;;
      -e)   _oext=1 ;;
      -f)   _ofir=1 ; _ospl=1 ;;
      -g)   _oext=2 ;;
      -p)   _opar=1 ; _ospl=1 ;;
      -w)   _owrk=1 ;;
      *)    _cen_abort - "$1"
      esac ; shift
    done
    [ -z "$_vset" ] && _cen_abort = '-a'        # missing option
    _path="${1:-.}" ; [ "$_path" = '.' ] && _path="$PWD"

    # remove trailing or leading slash, prettify
    case "$_path" in
        /)      [ -n "$_ospl" ] && _vvaa=("")
                _path="/" ; _ofir= ; _opar= ; _ospl= ;;
        /*/)    _path="${_path:1}" ; _pref="/"
                _cen_path_pretty _path "${_path::-1}" ; [ -n "$_oext" ] && _odmy=1 ; _oext= ;;
        /*)     _cen_path_pretty _path "${_path:1}" ; _pref="/" ;;
        */)     _cen_path_pretty -p _path "${_path::-1}" ; [ -n "$_oext" ] && _odmy=1 ; _oext= ;;
        *)      _cen_path_pretty -p _path "$_path"
    esac

    if [[ "$_path" == *..* ]] ; then            # must canonicalize path ...
        sysrun -q -r -b -a _path -- readlink -s -m -- "$1" || return 2
    fi

    [ "$_path" = '/' ] && return 1              # root has no parent

    if [ -n "$_ofir" ] ; then
        _left="${_path%%/*}" ; _righ="${_path#*/}"
    elif [ -n "$_opar" ] ; then
        _left="${_path%/*}" ; _righ="${_path##*/}"
    fi

    if [ -n "$_ospl" ] ; then
        if [ "$_left" = "$_righ" ] ; then
            _vvaa=("$_pref") ; _path="$_righ"
        else
            _vvaa=("$_pref$_left") ; _path="$_righ"
        fi
    else
        _path="$_pref$_path"
    fi

    if [ "$_oext" = 2 ] ; then                  # separate extensions (greedy)
        _left="${_path%%.*}" ; _righ="${_path#*.}"
        [ "$_left" = "$_righ" ] && _righ=
        _vvaa+=("$_left" "$_righ")
    elif [ -n "$_oext" ] ; then                 # separate parent path (greedy)
        _left="${_path%.*}" ; _righ="${_path##*.}"
        [ "$_left" = "$_righ" ] && _righ=
        _vvaa+=("$_left" "$_righ")
    else
        _vvaa+=("$_path")
        [ -n "$_odmy" ] && _vvaa+=("")
    fi

    if [ -n "$_owrk" ] ; then                   # strip $PWD
        [ "$_vvaa" = "$PWD" ] && _vvaa= || _vvaa="${_vvaa#$PWD/}"
    fi
    return 0
}

# ------------------------------------------------------------------------------
# suffixpath - add or remove a suffix to or from a file path
#
# Call:     (1) suffixpath [-s <varname>] [-d] [-l] [-c <from>] [--] <suffix> [<path>]
#           (2) suffixpath [-s <varname>] [-r] [-l] [-c <from>] [--] <suffix>|- [<path>]
#
# Options:  -c  change suffix
#           -d  only append if path has no other suffix
#           -l  lower case
#           -r  remove one suffix (use - to match any suffix)
#           -s  variable to be used (default is CEN_SUFFIXPATH)
#
# Arguments:<varname>  a variable holding the path
#           <suffix>   suffix to be append
#           <path>     use this path or use current <varname> if missing
#
# Return:   **true** at success. If <path> is a folder or ends with a "/" or for an
#           attempt to remove non-existing suffix **false** is returned.
#
#+The function implements some logic to handle default suffixes. It is used by
# [[inpfile()]] and [[outfile()]] for this purpose:
#
#,          - If the path is empty or ends with **/** or is an existing folder, the
#,            function does nothing and returns **false**.
#
#,          - A path ending on **.** causes the dot to be removed and no further action
#,            to be taken. This can be used to prevent this function from addind any
#,            default suffix to a path.
#
#,          - If the suffix does not start with a **.** character it is prefixed with
#,            one.
#
# Examples: simply adding a suffix:
#.          suffixpath 'bak' 'my-file.txt'      # results in: my-file.txt.bak
#.          suffixpath 'dat' '/tmp/scratch'     # results in: /tmp/scratch.dat
#.          suffixpath 'dat' '/tmp/scratch.'    # results in: /tmp/scratch
#.          suffixpath 'dat' '/tmp/scratch/'    # results in: /tmp/scratch/
#.          suffixpath 'dat' '/tmp'             # results in: /tmp  (ignore folder)
#
#           adding a default suffix:
#.          suffixpath -d 'gpx'  'my-track'     # results in: my-track.gpx
#.          suffixpath -d 'gpx'  'my-track.tmp' # results in: my-track.tmp
#.          suffixpath -d 'gpx'  'my-track.'    # results in: my-track
#
#           removing a suffix:
#.          if ! suffixpath -r 'bak' '$1' ; then
#.              message "File '$1' has no 'bak' suffix"
#.          fi
#.          case $? in
#.          1)  message "Got a folder:" "$1" ;;
#.          2)  message "File '$1' has no 'bak' suffix" ;;
#.          esac
# ------------------------------------------------------------------------------
CEN_SUFFIXPATH=
suffixpath() {
    local _vnam="CEN_SUFFIXPATH" _suff _from _optd _olow _orem
    while [ "${1::1}" = "-" ] ; do
        case "$1" in
        --)   shift ; break ;;
        -)    break ;;
        -c)   shift ; _from="$1" ;;
        -d)   _optd=1 ;;
        -l)   _olow=1 ;;
        -r)   _orem=1 ;;
        -s)   shift ; _vnam="$1" ;;
        *)    _cen_abort - "$1"
        esac ; shift
    done

    local -n _vsuf="$_vnam"
    [ $# -gt 1 ] && _vsuf="$2"                      # allow inplace operation

    # special cases: folder, remove trailing ., no suffix
    local _snam="${_vsuf##*/}"                      # path with suffix removed
    [ -z "$_snam" ] && return 1                     # empty or trailing / (is a folder)
    _snew="${1#.}" ; [ -z "$_snew" ] && return 1    # no suffix given
    if [ "${_snam:${#_snam}-1:1}" = "." ] ; then    # ending with '.'
        [ -d "$_vsuf" ] && return 1                 # do not touch a folder name
        _vsuf="${_vsuf::${#_vsuf}-1}" ; return 0    # remove dot
    fi
    local _scur="${_snam#*.}"                       # get current suffix

    # append a suffix
    if [ "$_scur" = "$_snam" ] ; then               # file has no suffix
        [ -n "$_orem" ] && return 0                 # nothing to remove
        [ -d "$_vsuf" ] && return 1                 # ignore folder
        _vsuf+=".$_snew" ; return 0
    elif [ -z "$_optd" -a -z "$_from" -a -z "$_orem" ] ; then
        [ -d "$_vsuf" ] && return 1                 # ignore folder
        _vsuf+=".$_snew" ; return 0
    fi

    # lower case
    if [ -n "$_olow" ] ; then
        _scur="${_scur,,}" ; _from="${_from,,}"
    fi

    # change current suffix
    if [ -n "$_from" ] && [ "$_from" = '-' -o "$_from" = "$_scur" ] ; then
        [ -d "$_vsuf" ] && return 1                 # ignore folder
        _vsuf="${_snam%.*}.$_snew" ; _scur="$_snew"
    fi

    # remove suffix
    [ -z "$_orem" ] && return 0
    if [ "$_orem" = '-' -o "$_scur" = "$_orem" ] ; then
        [ -d "$_vsuf" ] && return 1                 # ignore folder
        _vsuf="${_snam%.*}"
    fi
    return 0
}

# ------------------------------------------------------------------------------
# symlink - Make symlink single or multiple targets using /usr/bin/ln
#
# Call:     (1) symlink [-f|-q] [-i] [-n] [-m|-x] [-r] [-s] [--] <target> <link>
#           (2) symlink [-f|-q] [-i] [-n] [-m|-x] [-r] [-s] [--] <target> [<fldr>]
#           (3) symlink [-f|-q] [-n] [-r] [--] <target>... <fldr>
#           (4) symlink -n [-f|-q] [-r] [-s] [--] <target> <fldr>/<link>
#
# Options:  -c  canonicalize target path
#           -d  allow that <link> is a folder
#           -f  make errors fatal
#           -i  [*] no error message for missing <target>
#           -m  if link is a file/dir move it to '<link>.$CEN_NAME'
#           -n  [*] no checks, <link> will replace file (ln -f -s)
#           -q  do not report errors
#           -r  make relative links
#           -s  do not generate messages
#           -x  if <link> is a file/dir explicitly delete it
#
#           [*] use '-i -n' to allow the creation of stale symlinks
#
# Arguments:<target> location the symlink points to
#           <link>   name (or path) of symlink to be created
#           <fldr>   folder where to create the symlink
#
# Return:   **0** := OK   **1** := no <target>   **2** := <link> is a file
#
#+This is a conveniency wrapper for **/usr/bin/ln** (or the loadable bash builtin)
# that provides some extra reporting and error handling. Without option -n the
# form (1) and (2) refuse to create a ''symlink'' if <target> does not exist.
#
#+Form (3) can place multiple links into a folder but cannot check <target>...
# at all.
#
#+The function cannot check a relative <target> path with <link> being a folder,
# see form (4).
# ------------------------------------------------------------------------------
symlink() {
    local _fign _targ _ocan _odir _oftl='error' _onck _orel _osys='-e -p' _move _mesg="$CEN_TRACE"
    while [ "${1::1}" = "-" ] ; do
      case "$1" in
      --)   shift ; break ;;
      -c)   _ocan=1 ;;
      -d)   _odir=1 ;;
      -f)   _oftl="fatal" ; _osys="-f -p" ;;
      -i)   _fign=1 ;;
      -m)   _move=1 ;;
      -n)   _onck='-f' ;;
      -q)   _oftl=":" ; _osys="-q" ;;
      -r)   _orel=1 ;;
      -s)   _mesg=: ;;
      -v)   _mesg=message ;;
      -x)   _move=0 ;;
      *)    _cen_abort - "$1"
      esac ; shift
    done
    local _etxt _link="$2" _targ="$1"

    # multiple targets, link must be a folder, run /usr/bin/ln
    if [ $# -gt 2 ] ; then
        local _leng="$#" ; _link="${!_leng}"    # kde/kate highligt bug: "${!#}"
        folder ${_osys//-[ep]/} -- "$_link" || return 1
        sysrun $_osys -i -m "$_etxt" -d -- ln $_onck $_orel -s -- "$@" || return 1
        return
    fi

    if [ -z "$_link" ] ; then
        _link="${_targ##*/}"
    elif [ -n "$_odir" ] && [ -d "$_link" ] ; then
        _link="${_link%/}/${_targ##*/}"
    fi

    if [ -z "$_onck" -o -n "$_fign" ] ; then
        if [ ! -e "$_targ" ] ; then
            [ -z "$_fign" ] && $_oftl $"Link target does not exist:" "$_targ"
            [ -z "$_onck" ] && return 1
        elif [ "$_targ" -ef "$_link" ] ; then
            $_mesg -a -c $" valid" -- "$_link => $_targ" ; return 0
        else
            [ -n "$_ocan" ] && _cen_path_realp -c "$_targ" && _targ="$_logi"
        fi

        if [ -h "$_link" ] ; then
            remove -s -- "$_link" || return 2
            $_mesg -a -c $" removed" -- "$_link"
        elif [ -e "$_link" ] ; then
            if [ "$_move" = 0 ] ; then
                remove -d -s -- "$_link" || return 2
                $_mesg -a $"Link '$_link' file/fldr deleted"
            elif [ -n "$_move" ] ; then
                sysrun $_osys -b -- mv -f -- "$_link" "$_link.$CEN_NAME" || return 2
                $_mesg -a $"Link '$_link' file/fldr moved"": $_link.$CEN_NAME"
            elif [ -d "$_link" ] ; then
                $_oftl $"Link is an existing folder"": $_link" ; return 2
            else
                $_oftl $"Link is an existing file"": $_link" ; return 2
            fi
        fi
    fi

    # run 'ln' and disable builtin for option '-r'
    _etxt=$"Failed to create symbolic link"": $_link"
    if [ -n "$_orel" ] ; then
        sysrun $_osys -m "$_etxt" -i -- ln $_onck -s -r -- "$_targ" "$_link" || return 1
    else
        sysrun $_osys -b -m "$_etxt" -d -- ln $_onck -s "$_targ" "$_link" || return 1
    fi
    $_mesg -a -c $" created" -- "$_link => $_targ" ; return 0
}

# ------------------------------------------------------------------------------
# sysrun - run a command or builtin, optionally generate error messages
#
# Call:     (1) sysrun [-e|-f] [-p] [-m <mesg>] [-w <what>]
#                      [-a|-s <onam>] [-b|-i] [-d] [-n] [-r] [-z] [--] <cmd> <arg>...
#           (2) sysrun -q
#                      [-a|-s <onam>] [-b|-i] [-d] [-n] [-r] [-z] [--] <cmd> <arg>...
#           (3) sysrun -c <stat> [-f] [-m <mesg>] [--] [<cmd> <arg>...]
#
#+          This is a faster, simpler variant of [[system()]], see below. Form (1)
#           runs a command or builtin with error reporting, form (2) does no error
#           reporting at all. Form (3) can be used to generate error messages from
#           error codes.
#
# Options:  -a  capture <cmd> output into an array (overrides -p and -q)
#           -b  do not run a function, prefer builtin over external
#           -c  error code for reporting (<cmd> is not executed)
#           -d  use './' prefix if 1st arg starts with a '-'
#           -e  print error message if command <cmd> fails
#           -f  like -e but make errors fatal
#           -i  do not run a function or builtin, see **sysfind -i**
#           -m  custom format string for error message
#           -n  do no checks on <cmd> (implied if <cmd> is a path)
#           -p  discard **/dev/stdout**, capture **/dev/stderr**, pretty-print error message
#           -q  discard **/dev/stdout** and **/dev/stderr**, no error message
#           -r  ignore --dryrun
#           -s  capture <cmd> output into an string (overrides -p and -q)
#           -w  override command name in error message
#           -z  don't capture **/dev/stdout** (for use with -p)
#
# Arguments:<onam>  variable that receives the <cmd> output
#           <mesg>  printf format string with 2 string variables
#           <what>  shown in error message
#           <stat>  status code to report (**0** reports nothing)
#           <cmd>   a program name or path
#           <arg>   program argument, at least one argument is required
#
# Return:   **true** at success or **false** otherwise.
#
#+The options -e -f -p -q and -z of this function work like in [[system()]].
# The use of -c -m and -w offers extra functionality for error reporting.
# The main reason for using sysrun is performance:
#
#+The bash "$(<cmd>°<arg>...)" construct as it is used by [[system()]] creates a
# subshell for each command, which is time consuming and can spawn extra processes.
# On the other hand the temporary file used by sysrun has to be created on
# 1st use and later to be deleted in a quit hook, see [[quit()]].
#
#+So this function is good especially when builtin commands like **mkdir**, **rmdir**,
# **unlink** or **ln** are to be executed (as some methods in [[_centauri_bash_ext]] do).
# User script code might prefer calls to [[system()]] unless high performance is
# of particular importance.
#
#+Option -d helps to solve the problem of some tools (bash builtins) that do not
# implement -- to stop option parsing. This is done here by scanning for --, to
# remove it and to prefix the next argument with './' if it starts with a '-'.
#
#+Option -b will always use an available builtin and will not run script functions.
# Without -b sysrun behaves like [[system()]] and honors cached paths.
# Option -i can be used to run an external command rather than a builtin.
#
#+Using a full path for <cmd> overrides option -b and allows to ignore cached paths.
# This can be used for example to bypass a builtin. **Note:** It is not possible for
# a script to disable builtins via "enable -n". See [[sysfind()]]
#
#+A file created via [[tmpfile()]] is used to capture <cmd> output (options -a, -s or -p).
# Callers should set umask=66 to avoid a public readable file if XDG_RUNTIME_DIR
# is not available.
#
#+It is possible to use sysrun from a subshell, but the main process should have set
# the tmpfile base folder (like "tmpfile -n") before starting the subshell in order
# to remove temporary files.
#
#+Using sysrun to call a script function is not recommended, use "system -n" instead.
# This is because sysrun uses only a single file to capture output which prevents
# recursive use.
#
#.Examples: # print an error message
#.          sysrun -c 127 -m "%s: failed to create '%s'" xmkdir /xxx
#.              # xmkdir: failed to create '/xxx': Program not found
#.          sysrun -c 1 -m "%s: failed to create '%s'" mkdir /xxx
#.              # mkdir: failed to create '/xxx'
#.          sysrun -c 129 mytool
#.              # 'mytool' failed: Signal 1
#
#.          # run a program without capturing output:
#.          sysrun -r -z -- diff f1 f2
#
#.          # run a program (or builtin) discarding stdout:
#.          sysrun -d -- unlink -- -this-is-a-file
#.          sysrun -f -m "%s: cannot remove folder '%s'" rmdir /xxx
#
#.          # capture output into an array:
#.          sysrun -a aout -p -- ls -l && splitjoin -i aout
# ------------------------------------------------------------------------------
sysrun() {
    $CEN_NOTRACE set +x
    local _ecmd="$CEN_TRACE" _emsg
    local _ofmt _oign _osta _opre _orun _oout _owho _fqui _ffnd=1 _vstr _vnam
    while [ "${1::1}" = "-" ] ; do
      case "$1" in
      --)   shift ; break ;;
      -a)   shift ; _vnam="$1" ; _oout=0 ;;
      -b)   _ffnd=0 ;;
      -c)   shift ; _osta="$1" ;;
      -d)   _opre=1 ;;
      -e)   _ecmd=error ;;
      -f)   _ecmd=fatal ;;
      -i)   _oign='-i' ;;
      -m)   shift ; _emsg="$1" ; [ -z "$_oout" ] && _oout=0 ;;
      -n)   _ffnd= ;;
      -p)   _ofmt=1 ; [ -z "$_oout" ] && _oout=0 ;;
      -q)   _fqui=1 ; [ -z "$_oout" ] && _oout=0 ;;
      -r)   _orun="-r" ;;
      -s)   shift ; _vstr="$1" ; _oout=0
            local _cen_ext_sysrun ; _vnam='_cen_ext_sysrun' ;;
      -w)   shift ; _owho="$1" ;;
      -z)   _oout=1 ;;
      *)    _cen_abort - "$1"
      esac ; shift
    done

    local _xmsg _xerr _xarg _xtmp _xcmd="$1" _outf ; shift
    [ -z "$_vnam" -a -n "$_ofmt" ] && _vnam='_xerr'         # dummy for -p

    # run a command or builtin
    if [ -z "$_osta" ] ; then
        # option -n does no checks at all
        if [ -z "$_ffnd" ] ; then
            _opre=
        # having a path disables -n and -p options
        elif [ "${_xcmd/\//}" != "$_xcmd" ] ; then          # contains /
            _opre=
        # using sysfind and cache
        else
            _xtmp="${CEN_COMMANDS["${_xcmd:--}"]}"          # sysfind() cache
            if [ "$_xtmp" = '-' ] ; then                    # cached as builtin
                if [ -z "$_oign" ] ; then
                    _xtmp="$_xcmd"
                else
                    sysfind -i -s _xtmp -- "$_xcmd" || _osta=127
                fi
            elif [ -n "$_xtmp" ] ; then                     # cached as command
                _xtmp+="/$_xcmd"
                if [ "$_ffnd" = '0' ] ; then                # force builtins ...
                    # check for builtin, clear search path to disable autoload
                    if BASH_LOADABLES_PATH= enable -a "$_xcmd" &>/dev/null ; then
                        _xtmp="$_xcmd"
                    # if it's a shell function then try dynamic load
                    elif PATH= type -t -- "$_xcmd" >/dev/null ; then
                        [ -n "${CEN_MODULES["_centauri_bash_dyn"]}" ] &&
                            _cen_dyn_builtin "$_xcmd" >/dev/null && _xtmp="$_xcmd"
                    fi
                fi
            elif ! sysfind ${_oign:--b} -c -s _xtmp -- "$_xcmd" ; then
                _osta=127
            fi
            if [ "${_xtmp::1}" = '/' ] ; then               # run as command
                _opre= ; _xcmd="${_xtmp/\/\//\/}"
            elif [ -n "$_xtmp" ] ; then                     # run as builtin
                _xcmd='builtin' ; set -- "$_xtmp" "$@"
            fi
        fi
        [ -z "$_owho" ] && _owho="$_xcmd"
    fi

    # run command "$_xcmd" ...
    if [ -z "$_osta" ] ; then

        # stupid builtins: remove '--' from command line
        if [ -n "$_opre" ] ; then
            local _afix=()
            while [ $# -gt 0 ] ; do
                if [ "$1" == "--" ] ; then
                    if [ "${2::1}" = "-" ] ; then
                        _afix+=("./$2") ; shift
                    fi
                    shift ; break
                fi
                _afix+=("$1") ; shift
            done
            set -- "${_afix[@]}" "$@"
        fi || :
        if dryrun $_orun -- "$_xcmd" "$@" ; then
            $CEN_NOTRACE set -x ; return 1
        fi

        if [ -n "$_vnam" ] ; then                           # capture output
            _osta=0
            [ "$CEN_EXT_TPID" = "$$" ] && _outf="${CEN_EXT_TEMP}0" \
                                       || tmpfile ${_orun:+-r} -s _outf -f -n 0
            if [ "$_oout" = 0 ] ; then                      # ... capture all
                "$_xcmd" "$@" &>"$_outf" || _osta=$?
            else                                            # ... errors only
                "$_xcmd" "$@" 2>"$_outf" || _osta=$?
            fi
            IFS=$'\n' read -a "$_vnam" -d '' -r <"$_outf"
        elif [ "$_oout" = 0 ] ; then
            "$_xcmd" "$@" &>/dev/null ; _osta=$?
        else
            "$_xcmd" "$@" ; _osta=$?
        fi || :
    fi

    # create result string from array
    if [ -n "$_vstr" ] ; then
        local -n _rarr="$_vnam"
        if [ "${#_rarr[@]}" -le 1 ] ; then
            local -n _rslt="$_vstr" ; _rslt="$_rarr"
        else
            splitjoin -j "$_vstr" -d '\n' -i "$_vnam"
        fi
    fi

    # error reporting ...
    [ -z "$_osta" ] && _osta=1                  # must have a value here
    [ -n "$_fqui" ] && return $_osta
    case "$_osta" in
    0)      $CEN_NOTRACE set -x ; return 0 ;;
    1)      ;;
    2)      _xmsg=$"Invalid argument(s)" ;;
    126)    _xmsg=$"File not executable" ;;
    127)    _xmsg=$"Program not found" ;;
    *)      if [ "$_osta" -gt 128 ] ; then
                _xmsg=$"Signal"" $((_osta - 128))"
            else
                _xmsg=$"Status"" $_osta"
            fi
    esac

    [ "${_emsg:--}" = '-' ] && _emsg=$"Running '%s%s' failed"
    [ -n "$_xmsg" ] && _xmsg=": $_xmsg"
    if [ "$_ecmd" = "$CEN_TRACE" -a -n "$_ofmt" ] ; then    # system -p style
        splitjoin -j _xtmp -d '\n' -i "$_vnam"
        message -m "$_xtmp"
        $CEN_NOTRACE set -x ; return $_osta
    elif [ -n "$_ofmt" ] ; then                         # system -e -p style
        splitjoin -s _xtmp -d '\n' -i "$_vnam"
        _xarg=
        for _xtmp in "${_xtmp[@]}" ; do
            _xarg+="${_xtmp#/*: *: }"$'\n'              # strip bash error prefix
        done
        [ "$_xcmd" = 'builtin' ] && _xtmp=" $1" || _xtmp=
        $_ecmd -m -p "${_emsg} %s\n%s" "${_owho:-($_xcmd)}" "$_xtmp" "$_xmsg" "$_xarg"
    else                                                # simple ...
        $_ecmd -p "$_emsg$_xmsg" "${_owho:-($_xcmd)}" "$_xtmp"
    fi
    $CEN_NOTRACE set -x ; return $_osta
}

# ------------------------------------------------------------------------------
# tmpfile - create temporary files that get deleted on program exit
#
# Call:     (1) tmpfile -t|-v|-b <fldr>                  # set base folder
#           (2) tmpfile [-t|-v|-b <fldr>] [-p]           # create file/pipe
#                       [-f] [-n] [-s <name>] [<suff>]
#           (3) tmpfile [-t|-v|-b <fldr>] -d             # delete created files
#
#+          This documentation uses "/tmp" and "/var/tmp", but at runtime
#           these paths may differ, see $CEN_PATHS settings.
#
# Options:  -b  set base folder to <fldr> (default is $XDG_RUNTIME_DIR)
#           -d  delete all files created by tmpfile for this process
#           -f  make errors fatal
#           -n  do not actually create the file
#           -p  create a pipe (fifo) instead of a file
#           -r  ignore --dryrun
#           -s  use variable <name> to save result (default is CEN_TMPFILE)
#           -t  set base folder to "/tmp/centauri-<user>"
#           -v  set base folder to "/var/tmp/centauri-<user>"
#
# Arguments:<fldr>  folder path (use - for $XDG_RUNTIME_DIR)
#           <name>  name of result variable
#           <suff>  suffix to append to file name (default is a counter)
#
#.Examples: # create a temp file (might be in XDG_RUNTIME_DIR)
#.          tmpfile -s myfile test
#.          message "Base folder: $CEN_EXT_TEMP, temp file: $myfile"
#
#.          # create a temp file in /tmp/centauri-<user>
#.          tmpfile -t -s myfile test
#
#.          # delete current files, switch base folder to /var/tmp/...
#.          tmpfile -d ; tmpfile -v
#
#.          # create a spool file, then switch back to default base
#.          tmpfile -b "/var/spool/$CEN_NAME" -s myfile
#.          tmpfile -b -
#
#.          # delete a specific base folder (resets current base)
#.          tmpfile -b "/var/spool/$CEN_NAME" -d
#
#+If a <suff> string is used, it must not start with a digit. If <suff> is **-**,
# missing or empty an incrementing counter value is used instead.
#
#+Temp files are created inside a base folder (see CEN_EXT_TEMP). This folder
# is by default set and created at the 1st call. Changing the base folder via -t,
# -v or -b does not automatically delete prevously created files.
#
#+Daemons or services should use -v or unset XDG_RUNTIME_DIR. Otherwise systemd
# might delete the base folder, which in turn may cause severe problems as new
# temp files cannot be created any longer. The [[_cen_bash_svc]] module unsets
# XDG_RUNTIME_DIR on load.
#
#+For performance reasons the function does not set umask. Although temporary
# files are usually created in the private XDG_RUNTIME_DIR or a private folder
# in "/var/tmp", any custom folder can be specified via -b. In the later case
# the caller's umask may lead to a temporary file that is public readable.
#
#+The function registers a quit hook to delete created files on exit. A bash
# glob with '*' appended to CEN_EXT_TEMP selects the files to be deleted.
# **Note:** only files and folders in the current base folder get deleted.
#
#+When using tmpfile from a subshell care must been taken to remove temp files.
# The subshell code must not call [[quit()]] but can safely call "tempfile -d".
# Terminating the main shell via quit() may unexpectedly delete temp files of
# subshells:
#
#.          # save subshell use ...
#.          tmpfile -n                      # main shell registers hook
#.          do_background &                 # run subshell
#.          do_something_else
#.          wait ; quit                     # wait for subshell before quit
# ------------------------------------------------------------------------------
CEN_TMPFILE=
tmpfile() {
    local _odel _oftl _onoc _opip _oerr='error -z' _orun _updt _snam='CEN_TMPFILE' _base
    while [ "${1::1}" = "-" ] ; do
      case "$1" in
      -)    break ;;
      --)   shift ; break ;;
      -b)   shift ; [ "${1:--}" = '-' ] || _base="${1%/}" ; _updt=1 ;;
      -d)   _odel=1 ;;
      -f)   _oerr=fatal ; _oftl='-f' ;;
      -n)   _onoc=1 ;;
      -p)   _opip=1 ;;
      -r)   _orun='-r' ;;
      -s)   shift ; _snam="$1" ;;
      -t)   _base= ; _updt=1 ;;
      -v)   _base='-' ; _updt=1 ;;
      *)    _cen_abort - "$1"
      esac ; shift
    done

    # make sure to have a base folder
    if [ -z "$_base" -a -z "$_updt" ] ; then
        _base="${XDG_RUNTIME_DIR:-$CEN_EXT_TEMP}"
        [ -z "$_base" ] && _updt=1
    fi

    # detect sub-shell use
    local _ssuf                                         # extra suffix for subshell
    if [ "$CEN_EXT_TPID" != "$BASHPID" ] ; then
            [ -z "$CEN_EXT_TPID" ] && _updt=1           # 1st time: init base folder
            CEN_EXT_TIDX=1
            CEN_EXT_TPID="$BASHPID"
    fi

    # temp file naming
    #       <name>-<$$>-<indx>              # main process
    #       <name>-<$$>-<BASHPID>-<indx>    # child process
    [ "$CEN_EXT_TPID" != "$$" ] && _ssuf="$BASHPID-"

    # set base folder

    if [ -n "$_updt" ] ; then                           # get base-folder name
        local _name="${LOGNAME:-$USER}"
        [ "$EUID" = '0' ] && _name='root'
        [ "$_base" = '-' ] &&                           # use /var/tmp
            [ -d "${CEN_PATHS[3]}/tmp" ] && _base="${CEN_PATHS[3]}/tmp/centauri-${_name:-$EUID}"
        [ "${_base:--}" = '-' ] &&                      # fallback and/or use /tmp
            _base="${CEN_PATHS[4]}/centauri-${_name:-$EUID}"

        if [ -z "$_odel" ] ; then
            if [ -n "$CEN_EXT_TEMP" ] ; then
                _updt="${CEN_EXT_TEMP%/*}"
                [ "$_updt" = "$_base" ] || $CEN_TRACE2 -c $" update" -- "$_updt => $_base"
            fi
            folder $_oftl $_orun -m -s _base -- "$_base" 700 || return 1
        fi
        CEN_EXT_TEMP=
        _base+="/$CEN_NAME-$$-"
    else
        _base="$CEN_EXT_TEMP"
    fi

    # delete temp files (ignores --dryrun)

    if [ -n "$_odel" ] ; then
        [ -z "$_base" ] && return 0                     # not initialized
        $CEN_TRACE2 -c $" remove" -- "$_base$_ssuf*"
        CEN_EXT_TEMP= ; CEN_TMPFILE=
        [ -d "$_base" ] && return 0                     # don't remove folder
        set +f ; set -- "$_base$_ssuf"*                 # make sure glob is on
        [ "$1" = "$_base$_ssuf*" ] && return 0          # nothing to remove
        sysrun $_orun -q -b -- rm -f -- "$@" ; return   # return status
    fi

    # create folder / file

    if [ -z "$CEN_EXT_TEMP" ] ; then                    # create folder, set hook
        CEN_EXT_TEMP="$_base"
    fi
    [ -n "$_onoc" -a -z "$_snam" ] && return 0          # init only

    local _suff="${1:--}" ; local -n _svar="$_snam"
    case "$_suff" in
    -)  _svar="$CEN_EXT_TEMP$_ssuf$((CEN_EXT_TIDX++))" ;;
    .*) _svar="$CEN_EXT_TEMP$_ssuf${_suff#.}" ;;
    *)  _svar="$CEN_EXT_TEMP$_ssuf$_suff"
    esac
    [ -n "$_onoc" ] && return 0                         # do not create

    if [ -z "$_opip" ] ; then
        dryrun $_orun ">'$_svar'" && return 1
        2>/dev/null >"$_svar" && return 0
        $_oerr $"Cannot create" "$_svar" || return 1
    else
        sysrun -e -b $_orun -- mkfifo "$_svar" || return 1
    fi
    return 0
}

# ------------------------------------------------------------------------------
# trimjoin - remove leading/trailing whitespace and optionally join
#
# Call:     (1) trimjoin [-s <name>] [-a] [-l|-t] [-m <maxl>] [-c] [-w]
#           (2) trimjoin [-s <name>] [-a] [-l|-t] [-m <maxl>] [-c] [-w] [--] <text>
#           (3) trimjoin [-s <name>] [-a] [-d <deli>] [-m <maxl>] [-l|-t] [-c] [-w] [--] <text>...
#
#           Form (1) works inplace and form (3) does a join operation
#
# Options:  -a  append to output
#           -c  replace all control chars with spaces
#           -d  use <deli> to separate items (default is ' ')
#           -l  don't trim trailing (default is trim leading and trailing)
#           -m  shorten string if <maxl> is exceeded
#           -t  don't trim leading
#           -s  use <name> to save result (default is CEN_TRIMJOIN)
#           -w  simplify whitespace (<TAB>, <CR> and <LF> are whitspace)
#
#.Examples: trimjoin -- "  hi  "                    # trim into CEN_TRIMJOIN
#.          trimjoin -a -- "there"                  # append
#.          trimjoin -a -t " right trim only"
#
#.          local test ; printf -v test "  hello\t \aworld\a  \n\r"
#.          trimjoin -c -w -s text                  # inplace operation
#
#.          trimjoin -d ", " "one" "two" "three"    # comma separated list
# ------------------------------------------------------------------------------
CEN_TRIMJOIN=
trimjoin() {
    local _oapp _octl _olea=1 _omax _otra=1 _ospa _deli=' ' _drun _strm _snam='CEN_TRIMJOIN'
    while [ "${1::1}" = "-" ] ; do
      case "$1" in
      --)   shift ; break ;;
      -a)   _oapp=1 ;;
      -c)   _octl=1 ;;
      -d)   shift ; _deli="$1" ;;
      -l)   _otra= ;;
      -m)   shift ; _omax="${1:--}" ;;
      -s)   shift ; _snam="$1" ;;
      -t)   _olea= ;;
      -w)   _ospa=1 ;;
      *)    _cen_abort - "$1"
      esac ; shift
    done

    local -n _svar="$_snam"
    [ $# = 0 ] && set -- "$_svar"                   # allow inplace operation
    [ -z "$_oapp" ] && _svar=
    for _strm in "$@" ; do
        _svar+="$_drun"
        [ -n "$_octl" ] && _strm="${_strm//[[:cntrl:]]/ }"
        [ -n "$_otra" ] && _strm="${_strm%"${_strm##*[![:space:]]}"}"
        [ -n "$_olea" ] && _strm="${_strm#"${_strm%%[![:space:]]*}"}"
        _svar+="$_strm" ; _drun="$_deli"
    done

    if [ -n "$_ospa" ] ; then
        _strm="${_svar//[[:space:]]/ }" ; _strm="${_strm//  / }"
        while [ "$_strm" != "$_svar" ] ; do
            _svar="$_strm" ; _strm="${_svar//    / }" ; _strm="${_svar//  / }"
        done
    fi
    [ -n "$_omax" ] && _cen_compactify "$_snam" "$_omax"
    return 0
}

# ------------------------------------------------------------------------------
# walk - Iterate over files and folders
#
# Call:     walk [-a] [-d <fdir>] [-f <ffil>] [-i] [-e <extn>]
#                [-r] [-l <levl>] [--] <path>...
#
# Options:  -a  append to **CEN_WALK_xxx** arrays
#           -b  include broken symlinks
#           -c  case sensitive filter using --include|--exclude
#           -d  callback for directories   (default: **false**)
#           -e  filter files by extension, repeatable
#           -f  callback for files         (default: **true**)
#           -h  find hidden files and folders
#           -i  case insensitive filter using --include|--exclude
#           -l  limit for recursion levels (default: no limit)
#           -r  recurse into folders
#
# Arguments:<ffil>  command excuted for each file   (default **true**)
#           <fdir>  command excuted for each folder (default **true**)
#           <extn>  extension filter, example "-e xml -e html -e gpx"
#           <levl>  max recursion depth, **0** to disable recursion
#           <path>  any file or folder
#
# Variables:CEN_WALK_LEVEL  current recursion level (in callbacks)
#           CEN_WALK_DIRS   array of folders seen (canonicalized path)
#           CEN_WALK_FILES  array of files seen   (relative path)
#
# Return:    **0** := OK  **1** := empty  **2** := error  **3** := stopped
#
#+The walk function is not reentrant. Folder names are canonicalized and
# kept in a map to prevent folders from being walked multiple times.
# Symlinks to folders are resolved and recursion is not restricted to a
# single filesystem.
#
# Recursion uses bash globbing, which must not be turned off.
#
#+Recursion ignores file or folder names starting with a dot unless
# the -h option is used.
#
#+The --include and --exclude filter (enabled by option -c or -i) is run
# before and -d or -f callback. See [[filter()]] for details.
#
#+Callbacks:The optional caller supplied callback functions <fdir> and
#           <ffil> can be used for processing or filtering:
#
#,          <fdir> <canonical> <item>    # 1st arg is full path
#,          <ffil> <item>                # <item> is a relative path
#
#           The return value controls further processing by walk:
#
#,          0  -  append item to **CEN_WALK_xxx** array
#,          1  -  do not append to **CEN_WALK_xxx** array
#,          2  -  skip current folder
#,          3  -  stop walk
# ------------------------------------------------------------------------------
CEN_WALK_FILES=()
CEN_WALK_DIRS=()
CEN_WALK_LEVEL=0
declare -g -A CEN_WALK_DMAP

walk() {
    local _fdir=false _ffil=: _fexc=: _frec _fadd _fbro="-e" _fhid _fext=() _stat _levl=999999999
    while [ "${1::1}" = "-" ] ; do
      case "$1" in
      --)   shift ; break ;;
      -a)   _fadd=1 ;;
      -b)   _fbro="-n" ;;
      -c)   _fexc="filter --" ;;
      -d)   shift; _fdir="$1" ;;
      -e)   shift; _fext+=("$1") ;;
      -f)   shift; _ffil="$1" ;;
      -h)   _fhid=1 ;;
      -l)   shift; _levl="$1" ;;
      -r)   _frec=1 ;;
      -i)   _fexc="filter -i --" ;;
      *)    _cen_abort - "$1"
      esac ; shift
    done

    # recursive helper, args: <file|dir>...
    _cen_walk() {
        ((CEN_WALK_LEVEL += 1))
        local _item _inam _dirs=() _stat=0

        # loop over argument list
        for _item in "$@" ; do
            _item="${_item/\/\//\/}"
            if [ -d "$_item" ] ; then           # folder
                _dirs+=("$_item") ; continue
            fi
            [ $_fbro "$_item" ] || continue
            _inam="${_item##*/}"
            if [ -n "$_fext" ] ; then           # extension filter
                local _iext=0 _sext="${_inam##*.}"
                while [ $_iext -lt "${#_fext[@]}" ] ; do
                    if [ "$_sext" = "${_fext[_iext]}" ] ; then
                    _iext=-1 ; break
                    fi
                    ((_iext += 1))
                done
                [ $_iext = -1 ] || continue
            fi
            $_fexc "$_inam" || continue          # --incl/--excl
            $_ffil "$_item" ; _stat=$?           # user callback
            [ "$_stat" -ge 2 ] && break
            [ "$_stat" = 0 ] && CEN_WALK_FILES+=("$_item")
        done

        # recurse into folders
        if [ -n "$_dirs" -a "$_stat" -lt 3 ] ; then
            local _full _indx=0 _cen_walk_dirn
            resolve -a _cen_walk_dirn -m -- "${_dirs[@]}" || return 3
            for _item in "${_dirs[@]}" ; do
                _full="${_cen_walk_dirn[_indx++]}"
                [ -n "${CEN_WALK_DMAP[$_full]}" ] && continue
                CEN_WALK_DMAP[$_full]="$_item"
                _stat=0
                if [ "$_ffil" = "false" ] ; then  # --incl/--excl
                    $_fexc "${_full##*/}" ; _stat=$?
                fi
                if [ "$_stat" = 0 ] ; then
                    $_fdir "$_full" "$_item" ; _stat=$?
                fi
                [ "$_stat" -ge 3 ] && break
                [ "$_stat" = 0 ] && CEN_WALK_DIRS+=("$_full")
                [ -z "$_frec" -o "$_stat" = 2 ] && continue
                [ "$CEN_WALK_LEVEL" -gt "$_levl" ] && continue

                _stat=0
                if [ -n "$_fhid" ] ; then
                    _cen_walk "$_item"/.[!.]* "$_item"/* || _stat=$?
                else
                    _cen_walk "$_item"/* || _stat=$?
                fi
                [ "$_stat" -ge 2 ] && break
            done
        fi
        ((CEN_WALK_LEVEL -= 1))
        return "$_stat"
    }

    if [ -z "$_fadd" ] ; then
        CEN_WALK_FILES=() ; CEN_WALK_DIRS=() ; CEN_WALK_DMAP=()
    fi

    _stat=0 ; _cen_walk "$@" || _stat=$?
    [ "$_stat" -ge 3 ] && return "$_stat"
    [ "${#CEN_WALK_FILES[@]}" = 0 -a "${#CEN_WALK_DIRS[@]}" = 0 ] && return 1
    return 0
}

# ------------------------------------------------------------------------------
# Startup - module init
# ------------------------------------------------------------------------------

# delete temp files created by tmpfile
_cen_ext_quit() {
    [ "$CEN_EXT_TEMP" ] && tmpfile -d -r
}

:
# end
