#!/bin/bash
# ------------------------------------------------------------------------------
# _centauri_bash_pro = Centauri Bash Library Progress Display Support
#
# Call:     . _centauri_bash_pro
#
#+This module implements the [[progress()]] function, which is a frontend of
# two different implementations. One is in [[_centauri_bash_con]] and is used
# in console mode, the other is in [[_centauri_bash_win]] and is used in
# windows mode. These two modules cannot be loaded at the same time.
#
#+Console or windows mode are either enabled explicitly by calling [[console()]]
# or [[windows()]] or by using a library feature option, see [[_centauri_bash_lib]].
# Some functions implicitly load one of these modules. So the [[progress()]] function
# will load [[_centauri_bash_con]] implicitly if not yet in windows mode.
#
# Copyright Dr. J. Pfennig (c) 2022
# ------------------------------------------------------------------------------

CEN_MODULES["_centauri_bash_pro"]="0.01:1"

# CEN_CONSOLE           # imported ...
# CEN_WINDOWS

# ------------------------------------------------------------------------------
# progress - progress bar or incremental progress reporting
#
# Call:     progress [-a|-i] [-e] [-l] [-s <step>]
#                    [-d <delay>]                    # dryrun delay in [s]
#                    [-c <prog> [-p|-t <args>...]]   # incremental output
#           progress -p <fmt> [<args>...]            # line output (printf formatting)
#           progress -s <step> [-p|-t <args>...]     # step by
#           progress -t <args>...                    # line output
#           progress <fmt> [<args>...]               # same as: -p <fmt> -t <args>...
#           progress [-e]                            # -no args- clear progress output
#           progress -w <work> -s <step>
#                    -c <fmt> [<labl> [<done>]]      # progress iterator
#
#+          Progress reporting has two implementations (console and windows mode) that
#           behave similar but are not identical. The progress implementation in
#           [[_centauri_bash_svc]] is completely different, see [[progress (service)]].
#
# Options:  **••• console mode •••**
#           -a  indent all but 1st invokation
#           -c  incremental mode (ignored if arg is a number)
#           -d  add delay in dryrun mode
#           -e  end incremental/line mode (keep output)
#           -i  indent (no program name)
#           -l  line output (used also by -p and -c)
#           -p  line output, like -t but with printf formatting
#           -s  like "-c ." if <step> is a number
#           -t  line output (no -c), rewrite progress text (with -c)
#           -v  disable progress output in verbose/trace mode
#
#           **••• windows mode (options -a -i and -v are silently ignored) •••**
#           -c  set/increment progess bar (<proc> in percent)
#           -d  add <delay> in dryrun mode
#           -e  close window (same as progress without args)
#           -l  notification message
#           -p  set label (**printf** formatting)
#           -s  step by n (use 'n:m' to set total to m)
#           -t  set progress dialog label
#
# Examples: **••• working in console and windows mode •••**
#
#     simple line output (notification messages for windows mode)...
#.    progress -l "Breakfast at 7:00"         # notification for windows
#.    sleep 0.4
#.    progress -p "%s at %s" "Lunch" "13:00"  # notification for windows
#.    sleep 0.4
#.    progress -t "Dinner at 19:00"           # ignored for windows
#.    sleep 0.4
#
#     appending line output (shows a dialog in windows mode)...
#.    progress "Meals:"                       # windows: creates dialog
#.    sleep 0.4
#.    progress -c "Breakfast "                # windows: increment only
#.    sleep 0.4
#.    progress -c "Lunch "
#.    sleep 0.4
#.    progress -c "Dinner"
#.    sleep 0.4
#.    progress                                # clear mesg., close dialog
#
#     show a list of steps (notification messages for windows mode)...
#.    progress -l "Winter" "Jan - Mar"
#.    sleep 0.4
#.    progress -l "Spring" "Apr - Jun"
#.    sleep 0.4
#.    progress -l "Summer" "Jul - Sep"
#.    sleep 0.4
#.    progress -l "Autumn" "Oct - Dec"
#
#     run an iterator (calling a worker $# time, progress report is made
#     only if $# is at least 20)...
#.    worker() { return 0 ; }
#.    progress -w worker -d 0.1 -s $#:20 -c "Step %s of %s ..." \
#.             "Progress Demo -" "Completed."
#
#
#           ••• console mode only •••
#
#           Show dots progress bar (compatible with windows mode) ...
#.          progress "Running "
#.          for item in 0 1 2 3 4 5 6 7 8 9 ; do
#.              sleep 1
#.              progress -c "."
#.          done
#.          quit "Demo over"
#
#           Incremental progress reporting ...
#.          progress -l "Wait for init ..."     # temporary message
#.          sleep 3
#.          message "Init done"                 # replace temp msg
#.
#.          progress -a -l "Phase I"            # new temp msg
#.          sleep 3
#.          progress -a -l "Phase II"           # replace tmp msg
#.          sleep 3
#.          progress                            # remove tmp msg
#.          sleep 3
#.          quit "Demo over"
#
#           ••• windows mode only •••
#
#.    progress "start"                   # show dialog, set label
#.    progress -c "."                    # increment progress
#.    progress "new label"               # set label
#.    progress -t "another label"        # set label only
#.    progress -c 40                     # set progress to 40%
#.    progress -c 70 -t "hallo"          # set progress and label
#.    progress                           # clear
#
#.    progress -s :3                     # set total steps (don't create dlg)
#.    progress -s 2                      # add to current
#.    progress -s 1:5 -t "Init"          # set total, show, add to current
#.    progress -s 2 "Step"               # add to current
#
# ------------------------------------------------------------------------------
progress() {

    # parse options
    local _prog _fdel _fend _flin _find _ftxt _foff _step _work _stat=0 _aind="$CEN_AUTOIND"
    while [ "${1::1}" = "-" ] ; do
      case "$1" in
      --)   shift ; break ;;
      -a)   _find="-a" ;;
      -c)   shift ; _prog="$1" ;;
      -d)   shift ; [ -n "$CEN_OPT_DRYRUN" ] && _fdel="$1" ;;
      -e)   _fend=1 ;;
      -i)   _find="-i" ;;
      -l)   _flin=1 ;;
      -p)   _ftxt=2 ;;
      -s)   shift ; _step="$1" ;;
      -t)   _ftxt=1 ;;
      -v)   [ "$CEN_VERB" -gt 1 ] && _foff=1 ;;
      -w)   shift ; _work="$1" ;;
      *)    _cen_abort - "$1"
      esac ; shift
    done

    # get console / windows status, init console mode

    if [ -z "$CEN_CONSOLE" ] ; then             # console() has not run
        if [ "$CEN_OPT_GUI" = 0 ] ; then        # disables auto-init
            _foff=1
        elif [ -z "${CEN_MODULES["_centauri_bash_win"]}" ] ; then
            console || _stat=$?
        elif [ -z "$CEN_WINDOWS" ] ; then       # _centauri_bash_win is loaded
             windows || _stat=$?                # must run windows()
        fi
        if [ -n "$_work" ] ; then               # must always run
            :
        elif [ "$_stat" != 0 ] ; then           # failed to init
            return $_stat
        elif [ -n "$CEN_WINDOWS" ] ; then       # foreward to _centauri_bash_win
            _cen_win_prog "$_prog" "$_fdel" "$_fend" "$_flin" "$_step" "$_ftxt" "$@" || _stat=$?
            return $_stat
        fi
    fi

    # disable for --quiet or output not to console
    [ -n "$CEN_PAGER" ] && _foff=1
    [ "${CEN_CONSOLE:-1}" = 0 ] && _foff=1

    if [ -n "$_work" ] ; then                   # worker mode
        local _mini="${_step#*:}" ; [ "$_mini" = "$_step" ] && _mini=1
        [ -n "$_foff" ] && _mini=0
        _cen_pro_work "$_work" "$_fdel" "${_step%:*}" "$_mini" "$_prog" "$@" || _stat=$?
    elif [ -z "$_foff" ] ; then
         _cen_con_prog "$_prog" "$_fend" "$_flin" "$_find" "$_step" "$_ftxt" "$@" || _stat=$?
        [ -n "$_fdel" ] && sleep "$_fdel"
    fi
    return "$_stat"
}

# ------------------------------------------------------------------------------
# helper for progress: <work> <fdel> <totl> <mini> <frmt> <text> [<done>]
#                      <work> <fdel> <totl>
#
#     <work>    (-w) worker function
#     <fdel>    (-d) debug delay
#     <totl>    (-s) total item count
#     <mini>    (-s) treshold for progress to be shown
#     <frmt>    (-c) printf format for n of m
#     <text>    extra text (prefix)
#     <done>    message
#
# called from progress() in _centauri_bash_pro
# ------------------------------------------------------------------------------
_cen_pro_work() {
    local _work="$1" _fdel="$2" _totl="$3" _mini="${4:-0}" _frmt="$5" _text="$6" _done="$7"
    [ "$_text" = '-' ] && _text=$"%s of %s"
    isfunction -a -- "$_work"

    # disable progress if _totl <= _mini or for _mini=0
    local _perc _mesg _epoc _curr=0 _plst=0 _stat=0
    [ "$_totl" -le "$_mini" -o "$_mini" = 0 ] && _plst=
    [ -n "$CEN_CONSOLE" ] && context -t +       # register trap handler

    while [ "$_curr" -lt "$_totl" ] ; do
        _perc=$((_curr++ * 100 / _totl))
        if [ -n "$_plst" ] ; then               # only if progress is enabled ...
            [ "$_perc" -gt "99" ] && _perc=99   # maximum 99%, see windows mode

            # report if % value changed or once per second
            if [ "$_perc" -gt "$_plst" -o "$EPOCHSECONDS" != "$_epoc" ] ; then
                _epoc="$EPOCHSECONDS" ; _plst="$_perc"
                printf -v _mesg -- "$_frmt" "$_curr" "$_totl"
                progress -a -c "$_perc" -t "$_text" "$_mesg"
            fi
        fi

        $_work "$_curr" || _stat=$?             # call worker
        [ "$_stat" = 0 ] || break               # error stop
        [ -n "$_fdel" ] && sleep "$_fdel"
    done

    # clear progress, close dialog, flush worker
    if [ -n "$_plst" ] ; then
        if [ "${_done:--}" != '-' ] ; then
            progress -a -c 100 -t "$_text" "$_done"
            sleep 0.5
        else
            progress -a -c 100
        fi
    fi
    $_work 0 || _stat_$?                        # flush worker
    [ -n "$_fdel" ] && sleep "$_fdel"
    [ -n "$CEN_CONSOLE" ] && context -t -       # reset trap handler
    return "$_stat"
}

:
# end
